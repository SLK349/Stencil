{"version":3,"names":["shouldUseCloseWatcher","config","get","win","undefined","blockHardwareBackButton","document","addEventListener","startHardwareBackButton","doc","busy","backButtonCallback","index","handlers","ev","CustomEvent","bubbles","detail","register","priority","handler","push","id","dispatchEvent","executeAction","async","handlerRegister","result","processHandlers","e","console","error","length","selectedHandler","Number","MIN_SAFE_INTEGER","forEach","filter","then","watcher","configureWatcher","destroy","CloseWatcher","onclose","OVERLAY_BACK_BUTTON_PRIORITY","MENU_BACK_BUTTON_PRIORITY"],"sources":["node_modules/@ionic/core/dist/collection/utils/hardware-back-button.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from \"./browser/index\";\nimport { config } from \"../global/config\";\n/**\n * CloseWatcher is a newer API that lets\n * use detect the hardware back button event\n * in a web browser: https://caniuse.com/?search=closewatcher\n * However, not every browser supports it yet.\n *\n * This needs to be a function so that we can\n * check the config once it has been set.\n * Otherwise, this code would be evaluated the\n * moment this file is evaluated which could be\n * before the config is set.\n */\nexport const shouldUseCloseWatcher = () => config.get('experimentalCloseWatcher', false) && win !== undefined && 'CloseWatcher' in win;\n/**\n * When hardwareBackButton: false in config,\n * we need to make sure we also block the default\n * webview behavior. If we don't then it will be\n * possible for users to navigate backward while\n * an overlay is still open. Additionally, it will\n * give the appearance that the hardwareBackButton\n * config is not working as the page transition\n * will still happen.\n */\nexport const blockHardwareBackButton = () => {\n    document.addEventListener('backbutton', () => { }); // eslint-disable-line\n};\nexport const startHardwareBackButton = () => {\n    const doc = document;\n    let busy = false;\n    const backButtonCallback = () => {\n        if (busy) {\n            return;\n        }\n        let index = 0;\n        let handlers = [];\n        const ev = new CustomEvent('ionBackButton', {\n            bubbles: false,\n            detail: {\n                register(priority, handler) {\n                    handlers.push({ priority, handler, id: index++ });\n                },\n            },\n        });\n        doc.dispatchEvent(ev);\n        const executeAction = async (handlerRegister) => {\n            try {\n                if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {\n                    const result = handlerRegister.handler(processHandlers);\n                    if (result != null) {\n                        await result;\n                    }\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n        };\n        const processHandlers = () => {\n            if (handlers.length > 0) {\n                let selectedHandler = {\n                    priority: Number.MIN_SAFE_INTEGER,\n                    handler: () => undefined,\n                    id: -1,\n                };\n                handlers.forEach((handler) => {\n                    if (handler.priority >= selectedHandler.priority) {\n                        selectedHandler = handler;\n                    }\n                });\n                busy = true;\n                handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);\n                executeAction(selectedHandler).then(() => (busy = false));\n            }\n        };\n        processHandlers();\n    };\n    /**\n     * If the CloseWatcher is defined then\n     * we don't want to also listen for the native\n     * backbutton event otherwise we may get duplicate\n     * events firing.\n     */\n    if (shouldUseCloseWatcher()) {\n        let watcher;\n        const configureWatcher = () => {\n            watcher === null || watcher === void 0 ? void 0 : watcher.destroy();\n            watcher = new win.CloseWatcher();\n            /**\n             * Once a close request happens\n             * the watcher gets destroyed.\n             * As a result, we need to re-configure\n             * the watcher so we can respond to other\n             * close requests.\n             */\n            watcher.onclose = () => {\n                backButtonCallback();\n                configureWatcher();\n            };\n        };\n        configureWatcher();\n    }\n    else {\n        doc.addEventListener('backbutton', backButtonCallback);\n    }\n};\nexport const OVERLAY_BACK_BUTTON_PRIORITY = 100;\nexport const MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays\n"],"mappings":";;;GAiBY,MAACA,EAAwB,IAAMC,EAAOC,IAAI,2BAA4B,QAAUC,IAAQC,WAAa,iBAAkBD,EAWvH,MAACE,EAA0B,KACnCC,SAASC,iBAAiB,cAAc,QAAU,EAE1C,MAACC,EAA0B,KACnC,MAAMC,EAAMH,SACZ,IAAII,EAAO,MACX,MAAMC,EAAqB,KACvB,GAAID,EAAM,CACN,MACZ,CACQ,IAAIE,EAAQ,EACZ,IAAIC,EAAW,GACf,MAAMC,EAAK,IAAIC,YAAY,gBAAiB,CACxCC,QAAS,MACTC,OAAQ,CACJ,QAAAC,CAASC,EAAUC,GACfP,EAASQ,KAAK,CAAEF,WAAUC,UAASE,GAAIV,KAC3D,KAGQH,EAAIc,cAAcT,GAClB,MAAMU,EAAgBC,MAAOC,IACzB,IACI,GAAIA,IAAoB,MAAQA,SAAyB,OAAS,EAAIA,EAAgBN,QAAS,CAC3F,MAAMO,EAASD,EAAgBN,QAAQQ,GACvC,GAAID,GAAU,KAAM,OACVA,CAC9B,CACA,CACA,CACY,MAAOE,GACHC,QAAQC,MAAMF,EAC9B,GAEQ,MAAMD,EAAkB,KACpB,GAAIf,EAASmB,OAAS,EAAG,CACrB,IAAIC,EAAkB,CAClBd,SAAUe,OAAOC,iBACjBf,QAAS,IAAMhB,UACfkB,IAAK,GAETT,EAASuB,SAAShB,IACd,GAAIA,EAAQD,UAAYc,EAAgBd,SAAU,CAC9Cc,EAAkBb,CAC1C,KAEgBV,EAAO,KACPG,EAAWA,EAASwB,QAAQjB,GAAYA,EAAQE,KAAOW,EAAgBX,KACvEE,EAAcS,GAAiBK,MAAK,IAAO5B,EAAO,OAClE,GAEQkB,GAAiB,EAQrB,GAAI5B,IAAyB,CACzB,IAAIuC,EACJ,MAAMC,EAAmB,KACrBD,IAAY,MAAQA,SAAiB,OAAS,EAAIA,EAAQE,UAC1DF,EAAU,IAAIpC,EAAIuC,aAQlBH,EAAQI,QAAU,KACdhC,IACA6B,GAAkB,CACrB,EAELA,GACR,KACS,CACD/B,EAAIF,iBAAiB,aAAcI,EAC3C,GAEY,MAACiC,EAA+B,IAChC,MAACC,EAA4B,U"}