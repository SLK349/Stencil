{"version":3,"names":["getDecimalPlaces","n","toString","split","length","roundToMaxDecimalPlaces","references","maxPlaces","Math","max","map","r","Number","toFixed","rangeIosCss","IonRangeIosStyle0","rangeMdCss","IonRangeMdStyle0","Range","constructor","hostRef","this","rangeId","rangeIds","didLoad","noUpdate","hasFocus","inheritedAttributes","contentEl","initialContentScrollY","clampBounds","value","clamp","min","ensureValueInBounds","dualKnobs","lower","upper","setupGesture","async","rangeSlider","gesture","import","createGesture","el","gestureName","gesturePriority","threshold","onStart","onMove","ev","onEnd","enable","disabled","handleKeyboard","knob","isIncrease","step","ratioA","ratioB","ionKnobMoveStart","emit","updateValue","emitValueChange","ionKnobMoveEnd","onBlur","ionBlur","onFocus","ionFocus","pressedKnob","undefined","color","debounce","name","label","pin","pinFormatter","round","snaps","ticks","activeBarStart","labelPlacement","debounceChanged","ionInput","originalIonInput","debounceEvent","minChanged","updateRatio","maxChanged","activeBarStartChanged","printIonWarning","disabledChanged","valueChanged","componentWillLoad","hasAttribute","getAttribute","inheritAriaAttributes","componentDidLoad","connectedCallback","findClosestIonContent","disconnectedCallback","destroy","getValue","_a","ionChange","detail","currentX","disableContentScrollY","setPressedKnob","update","clientX","resetContentScrollY","rect","ratio","left","width","isRTL","valueToRatio","ratioToValue","getBoundingClientRect","abs","setFocus","valA","valB","ratioLower","ratioUpper","shadowRoot","knobEl","querySelector","focus","hasStartSlotContent","hasEndSlotContent","hasLabel","renderRangeSlider","barStart","barEnd","rtl","start","end","tickStyle","tick","barStyle","ratioMin","ratioMax","active","push","h","class","ref","rangeEl","onPointerUp","style","role","part","renderKnob","pressed","render","inItem","hostContext","hasStartContent","needsStartAdjustment","hasEndContent","needsEndAdjustment","mode","getIonMode","renderHiddenInput","JSON","stringify","Host","key","onFocusin","onFocusout","id","createColorClasses","knobStyle","ariaLabel","onKeyDown","preventDefault","stopPropagation","tabindex","clampedValue"],"sources":["node_modules/@ionic/core/dist/collection/utils/floating-point/index.js","node_modules/@ionic/core/dist/collection/components/range/range.ios.css?tag=ion-range&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.md.css?tag=ion-range&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport function getDecimalPlaces(n) {\n    if (n % 1 === 0)\n        return 0;\n    return n.toString().split('.')[1].length;\n}\n/**\n * Fixes floating point rounding errors in a result by rounding\n * to the same specificity, or number of decimal places (*not*\n * significant figures) as provided reference numbers. If multiple\n * references are provided, the highest number of decimal places\n * between them will be used.\n *\n * The main use case is when numbers x and y are added to produce n,\n * but x and y are floats, so n may have rounding errors (such as\n * 3.1000000004 instead of 3.1). As long as only addition/subtraction\n * occurs between x and y, the specificity of the result will never\n * increase, so x and y should be passed in as the references.\n *\n * If multiplication, division, or other operations were used to\n * calculate n, the rounded result may have less specificity than\n * desired. For example, 1 / 3 = 0.33333(...), but\n * roundToMaxDecimalPlaces((1 / 3), 1, 3) will return 0, since both\n * 1 and 3 are whole numbers.\n *\n * Note that extremely precise reference numbers may lead to rounding\n * errors not being trimmed, due to the error result having the same or\n * fewer decimal places as the reference(s). This is acceptable as we\n * would not be able to tell the difference between a rounding error\n * and correct value in this case, but it does mean there is an implicit\n * precision limit. If precision that high is needed, it is recommended\n * to use a third party data type designed to handle floating point\n * errors instead.\n *\n * @param n The number to round.\n * @param references Number(s) used to calculate n, or that should otherwise\n * be used as a reference for the desired specificity.\n */\nexport function roundToMaxDecimalPlaces(n, ...references) {\n    const maxPlaces = Math.max(...references.map((r) => getDecimalPlaces(r)));\n    return Number(n.toFixed(maxPlaces));\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n.range-knob-handle {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n.range-bar-container {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n.range-knob {\n  inset-inline-start: calc(50% - var(--knob-size) / 2);\n}\n\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 24px was chosen so the knob and its\n * shadow do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: #ffffff;\n  --knob-box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 6px 13px rgba(0, 0, 0, 0.12);\n  --knob-size: 26px;\n  --bar-height: 4px;\n  --bar-background: var(--ion-color-step-900, var(--ion-background-color-step-900, #e6e6e6));\n  --bar-background-active: var(--ion-color-primary, #0054e9);\n  --bar-border-radius: 2px;\n  --height: 42px;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 24px;\n  padding-inline-start: 24px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 24px;\n  padding-inline-end: 24px;\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active {\n  background: var(--ion-color-base);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: calc(8px + 0.75rem);\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: calc(8px + 0.75rem);\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n.range-bar-active.has-ticks {\n  border-radius: 0;\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  -webkit-margin-end: -2px;\n  margin-inline-end: -2px;\n}\n\n.range-tick {\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  border-radius: 0;\n  position: absolute;\n  top: 17px;\n  width: 4px;\n  height: 8px;\n  background: var(--ion-color-step-900, var(--ion-background-color-step-900, #e6e6e6));\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: var(--bar-background-active);\n}\n\n.range-pin {\n  transform: translate3d(0,  100%,  0) scale(0.01);\n  -webkit-padding-start: 8px;\n  padding-inline-start: 8px;\n  -webkit-padding-end: 8px;\n  padding-inline-end: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  min-width: 28px;\n  transition: transform 120ms ease;\n  background: transparent;\n  color: var(--ion-text-color, #000);\n  font-size: 0.75rem;\n  text-align: center;\n}\n\n/**\n * The -100% ensures the pin sits on top\n * of the range-knob-handle container.\n * We apply 11px so that the pin\n * text is closer to the knob inside of the container.\n * We also apply the 11px here instead of using \"top\"\n * otherwise the pin text will translate below the knob\n * when the text is scaled.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 11px), 0) scale(1);\n}\n\n:host(.range-disabled) {\n  opacity: 0.3;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n.range-knob-handle {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n.range-bar-container {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n.range-knob {\n  inset-inline-start: calc(50% - var(--knob-size) / 2);\n}\n\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 18px was chosen so the knob and its focus/active\n * effects do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: var(--bar-background-active);\n  --knob-box-shadow: none;\n  --knob-size: 18px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-color-primary-rgb, 0, 84, 233), 0.26);\n  --bar-background-active: var(--ion-color-primary, #0054e9);\n  --bar-border-radius: 0;\n  --height: 42px;\n  --pin-background: var(--ion-color-primary, #0054e9);\n  --pin-color: var(--ion-color-primary-contrast, #fff);\n}\n\n::slotted(:not(ion-icon)[slot=start]),\n::slotted(:not(ion-icon)[slot=end]),\n.native-wrapper {\n  font-size: 0.75rem;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 18px;\n  padding-inline-start: 18px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 18px;\n  padding-inline-end: 18px;\n}\n\n:host(.ion-color) .range-bar {\n  background: rgba(var(--ion-color-base-rgb), 0.26);\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-knob::before,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 14px;\n  margin-inline-end: 14px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 14px;\n  margin-inline-start: 14px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: 1.75rem;\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: 1.75rem;\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-knob {\n  transform: scale(0.67);\n  transition-duration: 120ms;\n  transition-property: transform, background-color, border;\n  transition-timing-function: ease;\n  z-index: 2;\n}\n.range-knob::before {\n  border-radius: 50%;\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  transform: scale(1);\n  transition: 0.267s cubic-bezier(0, 0, 0.58, 1);\n  background: var(--knob-background);\n  content: \"\";\n  opacity: 0.13;\n  pointer-events: none;\n}\n.range-knob::before {\n  inset-inline-start: 0;\n}\n\n.range-tick {\n  position: absolute;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  width: var(--bar-height);\n  height: var(--bar-height);\n  background: var(--bar-background-active);\n  z-index: 1;\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: transparent;\n}\n\n.range-pin {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  border-radius: 50%;\n  transform: translate3d(0,  0,  0) scale(0.01);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /**\n   * The dimensions of the range need\n   * to scale with the size of the text\n   * which is why we use dynamic dimensions here.\n   */\n  width: 1.75rem;\n  height: 1.75rem;\n  transition: transform 120ms ease, background 120ms ease;\n  background: var(--pin-background);\n  color: var(--pin-color);\n}\n.range-pin::before {\n  /**\n   * The -1px here moves the ::before\n   * psuedo-element down to create a uniform pin shape.\n   */\n  bottom: -1px;\n  -webkit-margin-start: -13px;\n  margin-inline-start: -13px;\n  /* stylelint-disable-next-line property-disallowed-list */\n  border-radius: 50% 50% 50% 0;\n  position: absolute;\n  width: 26px;\n  height: 26px;\n  transform: rotate(-45deg);\n  transition: background 120ms ease;\n  background: var(--pin-background);\n  content: \"\";\n  z-index: -1;\n}\n.range-pin::before {\n  inset-inline-start: 50%;\n}\n\n:host-context([dir=rtl]) .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-pin::before:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n/**\n * Move the pin up by its full height\n * plus a few pixels so the tip is above\n * (but not touching) the knob.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 4px), 0) scale(1);\n}\n\n@media (any-hover: hover) {\n  .range-knob-handle:hover .range-knob:before {\n    transform: scale(2);\n    opacity: 0.13;\n  }\n}\n.range-knob-handle.ion-activated .range-knob:before, .range-knob-handle.ion-focused .range-knob:before, .range-knob-handle.range-knob-pressed .range-knob:before {\n  transform: scale(2);\n}\n.range-knob-handle.ion-focused .range-knob::before {\n  opacity: 0.13;\n}\n.range-knob-handle.ion-activated .range-knob::before, .range-knob-handle.range-knob-pressed .range-knob::before {\n  opacity: 0.25;\n}\n\n:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,\n:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob {\n  transform: scale(1);\n}\n\n:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick {\n  background-color: var(--ion-color-step-250, var(--ion-background-color-step-250, #bfbfbf));\n}\n\n:host(.range-disabled) .range-knob {\n  transform: scale(0.55);\n  outline: 5px solid #fff;\n  background-color: var(--ion-color-step-250, var(--ion-background-color-step-250, #bfbfbf));\n}\n\n:host(.range-disabled) .label-text-wrapper,\n:host(.range-disabled) ::slotted([slot=start]),\n:host(.range-disabled) ::slotted([slot=end]) {\n  opacity: 0.38;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { findClosestIonContent, disableContentScrollY, resetContentScrollY } from \"../../utils/content/index\";\nimport { inheritAriaAttributes, clamp, debounceEvent, renderHiddenInput } from \"../../utils/helpers\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\nimport { roundToMaxDecimalPlaces } from \"../../utils/floating-point\";\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot label - The label text to associate with the range. Use the \"labelPlacement\" property to control where the label is placed relative to the range.\n * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.\n * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.\n *\n * @part tick - An inactive tick mark.\n * @part tick-active - An active tick mark.\n * @part pin - The counter that appears above a knob.\n * @part knob - The handle that is used to drag the range.\n * @part bar - The inactive part of the bar.\n * @part bar-active - The active part of the bar.\n * @part label - The label text describing the range.\n */\nexport class Range {\n    constructor() {\n        this.rangeId = `ion-r-${rangeIds++}`;\n        this.didLoad = false;\n        this.noUpdate = false;\n        this.hasFocus = false;\n        this.inheritedAttributes = {};\n        this.contentEl = null;\n        this.initialContentScrollY = true;\n        this.clampBounds = (value) => {\n            return clamp(this.min, value, this.max);\n        };\n        this.ensureValueInBounds = (value) => {\n            if (this.dualKnobs) {\n                return {\n                    lower: this.clampBounds(value.lower),\n                    upper: this.clampBounds(value.upper),\n                };\n            }\n            else {\n                return this.clampBounds(value);\n            }\n        };\n        this.setupGesture = async () => {\n            const rangeSlider = this.rangeSlider;\n            if (rangeSlider) {\n                this.gesture = (await import('../../utils/gesture')).createGesture({\n                    el: rangeSlider,\n                    gestureName: 'range',\n                    gesturePriority: 100,\n                    /**\n                     * Provide a threshold since the drag movement\n                     * might be a user scrolling the view.\n                     * If this is true, then the range\n                     * should not move.\n                     */\n                    threshold: 10,\n                    onStart: () => this.onStart(),\n                    onMove: (ev) => this.onMove(ev),\n                    onEnd: (ev) => this.onEnd(ev),\n                });\n                this.gesture.enable(!this.disabled);\n            }\n        };\n        this.handleKeyboard = (knob, isIncrease) => {\n            const { ensureValueInBounds } = this;\n            let step = this.step;\n            step = step > 0 ? step : 1;\n            step = step / (this.max - this.min);\n            if (!isIncrease) {\n                step *= -1;\n            }\n            if (knob === 'A') {\n                this.ratioA = clamp(0, this.ratioA + step, 1);\n            }\n            else {\n                this.ratioB = clamp(0, this.ratioB + step, 1);\n            }\n            this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });\n            this.updateValue();\n            this.emitValueChange();\n            this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });\n        };\n        this.onBlur = () => {\n            if (this.hasFocus) {\n                this.hasFocus = false;\n                this.ionBlur.emit();\n            }\n        };\n        this.onFocus = () => {\n            if (!this.hasFocus) {\n                this.hasFocus = true;\n                this.ionFocus.emit();\n            }\n        };\n        this.ratioA = 0;\n        this.ratioB = 0;\n        this.pressedKnob = undefined;\n        this.color = undefined;\n        this.debounce = undefined;\n        this.name = this.rangeId;\n        this.label = undefined;\n        this.dualKnobs = false;\n        this.min = 0;\n        this.max = 100;\n        this.pin = false;\n        this.pinFormatter = (value) => Math.round(value);\n        this.snaps = false;\n        this.step = 1;\n        this.ticks = true;\n        this.activeBarStart = undefined;\n        this.disabled = false;\n        this.value = 0;\n        this.labelPlacement = 'start';\n    }\n    debounceChanged() {\n        const { ionInput, debounce, originalIonInput } = this;\n        /**\n         * If debounce is undefined, we have to manually revert the ionInput emitter in case\n         * debounce used to be set to a number. Otherwise, the event would stay debounced.\n         */\n        this.ionInput = debounce === undefined ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce);\n    }\n    minChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    maxChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    activeBarStartChanged() {\n        const { activeBarStart } = this;\n        if (activeBarStart !== undefined) {\n            if (activeBarStart > this.max) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.max;\n            }\n            else if (activeBarStart < this.min) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.min;\n            }\n        }\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    valueChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    componentWillLoad() {\n        /**\n         * If user has custom ID set then we should\n         * not assign the default incrementing ID.\n         */\n        if (this.el.hasAttribute('id')) {\n            this.rangeId = this.el.getAttribute('id');\n        }\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\n    }\n    componentDidLoad() {\n        this.originalIonInput = this.ionInput;\n        this.setupGesture();\n        this.updateRatio();\n        this.didLoad = true;\n    }\n    connectedCallback() {\n        this.updateRatio();\n        this.debounceChanged();\n        this.disabledChanged();\n        this.activeBarStartChanged();\n        /**\n         * If we have not yet rendered\n         * ion-range, then rangeSlider is not defined.\n         * But if we are moving ion-range via appendChild,\n         * then rangeSlider will be defined.\n         */\n        if (this.didLoad) {\n            this.setupGesture();\n        }\n        this.contentEl = findClosestIonContent(this.el);\n    }\n    disconnectedCallback() {\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    getValue() {\n        var _a;\n        const value = (_a = this.value) !== null && _a !== void 0 ? _a : 0;\n        if (this.dualKnobs) {\n            if (typeof value === 'object') {\n                return value;\n            }\n            return {\n                lower: 0,\n                upper: value,\n            };\n        }\n        else {\n            if (typeof value === 'object') {\n                return value.upper;\n            }\n            return value;\n        }\n    }\n    /**\n     * Emits an `ionChange` event.\n     *\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitValueChange() {\n        this.value = this.ensureValueInBounds(this.value);\n        this.ionChange.emit({ value: this.value });\n    }\n    /**\n     * The value should be updated on touch end or\n     * when the component is being dragged.\n     * This follows the native behavior of mobile devices.\n     *\n     * For example: When the user lifts their finger from the\n     * screen after tapping the bar or dragging the bar or knob.\n     */\n    onStart() {\n        this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    /**\n     * The value should be updated while dragging the\n     * bar or knob.\n     *\n     * While the user is dragging, the view\n     * should not scroll. This is to prevent the user from\n     * feeling disoriented while dragging.\n     *\n     * The user can scroll on the view if the knob or\n     * bar is not being dragged.\n     *\n     * @param detail The details of the gesture event.\n     */\n    onMove(detail) {\n        const { contentEl, pressedKnob } = this;\n        const currentX = detail.currentX;\n        /**\n         * Since the user is dragging on the bar or knob, the view should not scroll.\n         *\n         * This only needs to be done once.\n         */\n        if (contentEl && this.initialContentScrollY === undefined) {\n            this.initialContentScrollY = disableContentScrollY(contentEl);\n        }\n        /**\n         * The `pressedKnob` can be undefined if the user just\n         * started dragging the knob.\n         *\n         * This is necessary to determine which knob the user is dragging,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         *\n         * This only needs to be done once since the knob won't change\n         * while the user is dragging.\n         */\n        if (pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        this.update(currentX);\n    }\n    /**\n     * The value should be updated on touch end:\n     * - When the user lifts their finger from the screen after\n     * tapping the bar.\n     *\n     * @param detail The details of the gesture or mouse event.\n     */\n    onEnd(detail) {\n        const { contentEl, initialContentScrollY } = this;\n        const currentX = detail.currentX || detail.clientX;\n        /**\n         * The `pressedKnob` can be undefined if the user never\n         * dragged the knob. They just tapped on the bar.\n         *\n         * This is necessary to determine which knob the user is changing,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         */\n        if (this.pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        /**\n         * The user is no longer dragging the bar or\n         * knob (if they were dragging it).\n         *\n         * The user can now scroll on the view in the next gesture event.\n         */\n        if (contentEl && initialContentScrollY !== undefined) {\n            resetContentScrollY(contentEl, initialContentScrollY);\n        }\n        // update the active knob's position\n        this.update(currentX);\n        /**\n         * Reset the pressed knob to undefined since the user\n         * may start dragging a different knob in the next gesture event.\n         */\n        this.pressedKnob = undefined;\n        this.emitValueChange();\n        this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    update(currentX) {\n        // figure out where the pointer is currently at\n        // update the knob being interacted with\n        const rect = this.rect;\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        if (this.snaps) {\n            // snaps the ratio to the current value\n            ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\n        }\n        // update which knob is pressed\n        if (this.pressedKnob === 'A') {\n            this.ratioA = ratio;\n        }\n        else {\n            this.ratioB = ratio;\n        }\n        // Update input value\n        this.updateValue();\n    }\n    setPressedKnob(currentX) {\n        const rect = (this.rect = this.rangeSlider.getBoundingClientRect());\n        // figure out which knob they started closer to\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';\n        this.setFocus(this.pressedKnob);\n    }\n    get valA() {\n        return ratioToValue(this.ratioA, this.min, this.max, this.step);\n    }\n    get valB() {\n        return ratioToValue(this.ratioB, this.min, this.max, this.step);\n    }\n    get ratioLower() {\n        if (this.dualKnobs) {\n            return Math.min(this.ratioA, this.ratioB);\n        }\n        const { activeBarStart } = this;\n        if (activeBarStart == null) {\n            return 0;\n        }\n        return valueToRatio(activeBarStart, this.min, this.max);\n    }\n    get ratioUpper() {\n        if (this.dualKnobs) {\n            return Math.max(this.ratioA, this.ratioB);\n        }\n        return this.ratioA;\n    }\n    updateRatio() {\n        const value = this.getValue();\n        const { min, max } = this;\n        if (this.dualKnobs) {\n            this.ratioA = valueToRatio(value.lower, min, max);\n            this.ratioB = valueToRatio(value.upper, min, max);\n        }\n        else {\n            this.ratioA = valueToRatio(value, min, max);\n        }\n    }\n    updateValue() {\n        this.noUpdate = true;\n        const { valA, valB } = this;\n        this.value = !this.dualKnobs\n            ? valA\n            : {\n                lower: Math.min(valA, valB),\n                upper: Math.max(valA, valB),\n            };\n        this.ionInput.emit({ value: this.value });\n        this.noUpdate = false;\n    }\n    setFocus(knob) {\n        if (this.el.shadowRoot) {\n            const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\n            if (knobEl) {\n                knobEl.focus();\n            }\n        }\n    }\n    /**\n     * Returns true if content was passed to the \"start\" slot\n     */\n    get hasStartSlotContent() {\n        return this.el.querySelector('[slot=\"start\"]') !== null;\n    }\n    /**\n     * Returns true if content was passed to the \"end\" slot\n     */\n    get hasEndSlotContent() {\n        return this.el.querySelector('[slot=\"end\"]') !== null;\n    }\n    get hasLabel() {\n        return this.label !== undefined || this.el.querySelector('[slot=\"label\"]') !== null;\n    }\n    renderRangeSlider() {\n        var _a;\n        const { min, max, step, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, pinFormatter, inheritedAttributes, } = this;\n        let barStart = `${ratioLower * 100}%`;\n        let barEnd = `${100 - ratioUpper * 100}%`;\n        const rtl = isRTL(this.el);\n        const start = rtl ? 'right' : 'left';\n        const end = rtl ? 'left' : 'right';\n        const tickStyle = (tick) => {\n            return {\n                [start]: tick[start],\n            };\n        };\n        if (this.dualKnobs === false) {\n            /**\n             * When the value is less than the activeBarStart or the min value,\n             * the knob will display at the start of the active bar.\n             */\n            if (this.valA < ((_a = this.activeBarStart) !== null && _a !== void 0 ? _a : this.min)) {\n                /**\n                 * Sets the bar positions relative to the upper and lower limits.\n                 * Converts the ratio values into percentages, used as offsets for left/right styles.\n                 *\n                 * The ratioUpper refers to the knob position on the bar.\n                 * The ratioLower refers to the end position of the active bar (the value).\n                 */\n                barStart = `${ratioUpper * 100}%`;\n                barEnd = `${100 - ratioLower * 100}%`;\n            }\n            else {\n                /**\n                 * Otherwise, the knob will display at the end of the active bar.\n                 *\n                 * The ratioLower refers to the start position of the active bar (the value).\n                 * The ratioUpper refers to the knob position on the bar.\n                 */\n                barStart = `${ratioLower * 100}%`;\n                barEnd = `${100 - ratioUpper * 100}%`;\n            }\n        }\n        const barStyle = {\n            [start]: barStart,\n            [end]: barEnd,\n        };\n        const ticks = [];\n        if (this.snaps && this.ticks) {\n            for (let value = min; value <= max; value += step) {\n                const ratio = valueToRatio(value, min, max);\n                const ratioMin = Math.min(ratioLower, ratioUpper);\n                const ratioMax = Math.max(ratioLower, ratioUpper);\n                const tick = {\n                    ratio,\n                    /**\n                     * Sets the tick mark as active when the tick is between the min bounds and the knob.\n                     * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.\n                     */\n                    active: ratio >= ratioMin && ratio <= ratioMax,\n                };\n                tick[start] = `${ratio * 100}%`;\n                ticks.push(tick);\n            }\n        }\n        return (h(\"div\", { class: \"range-slider\", ref: (rangeEl) => (this.rangeSlider = rangeEl),\n            /**\n             * Since the gesture has a threshold, the value\n             * won't change until the user has dragged past\n             * the threshold. This is to prevent the range\n             * from moving when the user is scrolling.\n             *\n             * This results in the value not being updated\n             * and the event emitters not being triggered\n             * if the user taps on the range. This is why\n             * we need to listen for the \"pointerUp\" event.\n             */\n            onPointerUp: (ev) => {\n                /**\n                 * If the user drags the knob on the web\n                 * version (does not occur on mobile),\n                 * the \"pointerUp\" event will be triggered\n                 * along with the gesture's events.\n                 * This leads to duplicate events.\n                 *\n                 * By checking if the pressedKnob is undefined,\n                 * we can determine if the \"pointerUp\" event was\n                 * triggered by a tap or a drag. If it was\n                 * dragged, the pressedKnob will be defined.\n                 */\n                if (this.pressedKnob === undefined) {\n                    this.onStart();\n                    this.onEnd(ev);\n                }\n            } }, ticks.map((tick) => (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\n                'range-tick': true,\n                'range-tick-active': tick.active,\n            }, part: tick.active ? 'tick-active' : 'tick' }))), h(\"div\", { class: \"range-bar-container\" }, h(\"div\", { class: \"range-bar\", role: \"presentation\", part: \"bar\" }), h(\"div\", { class: {\n                'range-bar': true,\n                'range-bar-active': true,\n                'has-ticks': ticks.length > 0,\n            }, role: \"presentation\", style: barStyle, part: \"bar-active\" })), renderKnob(rtl, {\n            knob: 'A',\n            pressed: pressedKnob === 'A',\n            value: this.valA,\n            ratio: this.ratioA,\n            pin,\n            pinFormatter,\n            disabled,\n            handleKeyboard,\n            min,\n            max,\n            inheritedAttributes,\n        }), this.dualKnobs &&\n            renderKnob(rtl, {\n                knob: 'B',\n                pressed: pressedKnob === 'B',\n                value: this.valB,\n                ratio: this.ratioB,\n                pin,\n                pinFormatter,\n                disabled,\n                handleKeyboard,\n                min,\n                max,\n                inheritedAttributes,\n            })));\n    }\n    render() {\n        const { disabled, el, hasLabel, rangeId, pin, pressedKnob, labelPlacement, label } = this;\n        const inItem = hostContext('ion-item', el);\n        /**\n         * If there is no start content then the knob at\n         * the min value will be cut off by the item margin.\n         */\n        const hasStartContent = (hasLabel && (labelPlacement === 'start' || labelPlacement === 'fixed')) || this.hasStartSlotContent;\n        const needsStartAdjustment = inItem && !hasStartContent;\n        /**\n         * If there is no end content then the knob at\n         * the max value will be cut off by the item margin.\n         */\n        const hasEndContent = (hasLabel && labelPlacement === 'end') || this.hasEndSlotContent;\n        const needsEndAdjustment = inItem && !hasEndContent;\n        const mode = getIonMode(this);\n        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n        return (h(Host, { key: 'cd70b5db9eae808a644643d7095a1b5264cbc5fe', onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-item': inItem,\n                'range-disabled': disabled,\n                'range-pressed': pressedKnob !== undefined,\n                'range-has-pin': pin,\n                [`range-label-placement-${labelPlacement}`]: true,\n                'range-item-start-adjustment': needsStartAdjustment,\n                'range-item-end-adjustment': needsEndAdjustment,\n            }) }, h(\"label\", { key: '78ef0523f0064d6b268ae17ef72f90094511d897', class: \"range-wrapper\", id: \"range-label\" }, h(\"div\", { key: '6e4b2051e770dabe80dcb9f412e9aae1859e9f33', class: {\n                'label-text-wrapper': true,\n                'label-text-wrapper-hidden': !hasLabel,\n            }, part: \"label\" }, label !== undefined ? h(\"div\", { class: \"label-text\" }, label) : h(\"slot\", { name: \"label\" })), h(\"div\", { key: '72cdb8f6657a3b84f759743cedd600020c954c6a', class: \"native-wrapper\" }, h(\"slot\", { key: 'f7a38d6bd63df5dc8b4470f1f4acaaf3e5c80514', name: \"start\" }), this.renderRangeSlider(), h(\"slot\", { key: 'ae74ac8c1da691e3be1b2f00dfd3c8419b9566ec', name: \"end\" })))));\n    }\n    static get is() { return \"ion-range\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"range.ios.scss\"],\n            \"md\": [\"range.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"range.ios.css\"],\n            \"md\": [\"range.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"debounce\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"How long, in milliseconds, to wait to trigger the\\n`ionInput` event after each change in the range value.\"\n                },\n                \"attribute\": \"debounce\",\n                \"reflect\": false\n            },\n            \"name\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The name of the control, which is submitted with the form data.\"\n                },\n                \"attribute\": \"name\",\n                \"reflect\": false,\n                \"defaultValue\": \"this.rangeId\"\n            },\n            \"label\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The text to display as the control's label. Use this over the `label` slot if\\nyou only need plain text. The `label` property will take priority over the\\n`label` slot if both are used.\"\n                },\n                \"attribute\": \"label\",\n                \"reflect\": false\n            },\n            \"dualKnobs\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Show two knobs.\"\n                },\n                \"attribute\": \"dual-knobs\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"min\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Minimum integer value of the range.\"\n                },\n                \"attribute\": \"min\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"max\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Maximum integer value of the range.\"\n                },\n                \"attribute\": \"max\",\n                \"reflect\": false,\n                \"defaultValue\": \"100\"\n            },\n            \"pin\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, a pin with integer value is shown when the knob\\nis pressed.\"\n                },\n                \"attribute\": \"pin\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"pinFormatter\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"PinFormatter\",\n                    \"resolved\": \"(value: number) => string | number\",\n                    \"references\": {\n                        \"PinFormatter\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::PinFormatter\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"A callback used to format the pin text.\\nBy default the pin text is set to `Math.round(value)`.\\n\\nSee https://ionicframework.com/docs/troubleshooting/runtime#accessing-this\\nif you need to access `this` from within the callback.\"\n                },\n                \"defaultValue\": \"(value: number): number => Math.round(value)\"\n            },\n            \"snaps\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the knob snaps to tick marks evenly spaced based\\non the step property value.\"\n                },\n                \"attribute\": \"snaps\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"step\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Specifies the value granularity.\"\n                },\n                \"attribute\": \"step\",\n                \"reflect\": false,\n                \"defaultValue\": \"1\"\n            },\n            \"ticks\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, tick marks are displayed based on the step value.\\nOnly applies when `snaps` is `true`.\"\n                },\n                \"attribute\": \"ticks\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"activeBarStart\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The start position of the range active bar. This feature is only available with a single knob (dualKnobs=\\\"false\\\").\\nValid values are greater than or equal to the min value and less than or equal to the max value.\"\n                },\n                \"attribute\": \"active-bar-start\",\n                \"reflect\": false\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the range.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"value\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"RangeValue\",\n                    \"resolved\": \"number | { lower: number; upper: number; }\",\n                    \"references\": {\n                        \"RangeValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"the value of the range.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"labelPlacement\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"'start' | 'end' | 'fixed' | 'stacked'\",\n                    \"resolved\": \"\\\"end\\\" | \\\"fixed\\\" | \\\"stacked\\\" | \\\"start\\\"\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Where to place the label relative to the range.\\n`\\\"start\\\"`: The label will appear to the left of the range in LTR and to the right in RTL.\\n`\\\"end\\\"`: The label will appear to the right of the range in LTR and to the left in RTL.\\n`\\\"fixed\\\"`: The label has the same behavior as `\\\"start\\\"` except it also has a fixed width. Long text will be truncated with ellipses (\\\"...\\\").\\n`\\\"stacked\\\"`: The label will appear above the range regardless of the direction.\"\n                },\n                \"attribute\": \"label-placement\",\n                \"reflect\": false,\n                \"defaultValue\": \"'start'\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"ratioA\": {},\n            \"ratioB\": {},\n            \"pressedKnob\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionChange` event is fired for `<ion-range>` elements when the user\\nmodifies the element's value:\\n- When the user releases the knob after dragging;\\n- When the user moves the knob with keyboard arrows\\n\\n`ionChange` is not fired when the value is changed programmatically.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionInput\",\n                \"name\": \"ionInput\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionInput` event is fired for `<ion-range>` elements when the value\\nis modified. Unlike `ionChange`, `ionInput` is fired continuously\\nwhile the user is dragging the knob.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionFocus\",\n                \"name\": \"ionFocus\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range has focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionBlur\",\n                \"name\": \"ionBlur\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range loses focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionKnobMoveStart\",\n                \"name\": \"ionKnobMoveStart\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user starts moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveStartEventDetail\",\n                    \"resolved\": \"RangeKnobMoveStartEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveStartEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveStartEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionKnobMoveEnd\",\n                \"name\": \"ionKnobMoveEnd\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user finishes moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveEndEventDetail\",\n                    \"resolved\": \"RangeKnobMoveEndEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveEndEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveEndEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"debounce\",\n                \"methodName\": \"debounceChanged\"\n            }, {\n                \"propName\": \"min\",\n                \"methodName\": \"minChanged\"\n            }, {\n                \"propName\": \"max\",\n                \"methodName\": \"maxChanged\"\n            }, {\n                \"propName\": \"activeBarStart\",\n                \"methodName\": \"activeBarStartChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }];\n    }\n}\nconst renderKnob = (rtl, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, pinFormatter, inheritedAttributes }) => {\n    const start = rtl ? 'right' : 'left';\n    const knobStyle = () => {\n        const style = {};\n        style[start] = `${ratio * 100}%`;\n        return style;\n    };\n    // The aria label should be preferred over visible text if both are specified\n    const ariaLabel = inheritedAttributes['aria-label'];\n    return (h(\"div\", { onKeyDown: (ev) => {\n            const key = ev.key;\n            if (key === 'ArrowLeft' || key === 'ArrowDown') {\n                handleKeyboard(knob, false);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n            else if (key === 'ArrowRight' || key === 'ArrowUp') {\n                handleKeyboard(knob, true);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n        }, class: {\n            'range-knob-handle': true,\n            'range-knob-a': knob === 'A',\n            'range-knob-b': knob === 'B',\n            'range-knob-pressed': pressed,\n            'range-knob-min': value === min,\n            'range-knob-max': value === max,\n            'ion-activatable': true,\n            'ion-focusable': true,\n        }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-label\": ariaLabel !== undefined ? ariaLabel : null, \"aria-labelledby\": ariaLabel === undefined ? 'range-label' : null, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && (h(\"div\", { class: \"range-pin\", role: \"presentation\", part: \"pin\" }, pinFormatter(value))), h(\"div\", { class: \"range-knob\", role: \"presentation\", part: \"knob\" })));\n};\nconst ratioToValue = (ratio, min, max, step) => {\n    let value = (max - min) * ratio;\n    if (step > 0) {\n        // round to nearest multiple of step, then add min\n        value = Math.round(value / step) * step + min;\n    }\n    const clampedValue = clamp(min, value, max);\n    return roundToMaxDecimalPlaces(clampedValue, min, max, step);\n};\nconst valueToRatio = (value, min, max) => {\n    return clamp(0, (value - min) / (max - min), 1);\n};\nlet rangeIds = 0;\n"],"mappings":"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"}