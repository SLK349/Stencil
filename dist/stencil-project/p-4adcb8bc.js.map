{"version":3,"names":["baseAnimation","isIos","createAnimation","duration","menuOverlayAnimation","menu","closedX","openedX","width","menuAnimation","backdropAnimation","isEndSide","addElement","menuInnerEl","fromTo","mode","getIonMode","opacity","backdropEl","addAnimation","menuPushAnimation","contentOpenedX","menuClosedX","contentAnimation","contentEl","menuRevealAnimation","contentOpen","createMenuController","menuAnimations","Map","menus","open","async","menuEl","get","close","undefined","getOpen","toggle","enable","shouldEnable","disabled","swipeGesture","isOpen","isEnabled","logOnMultipleSideMenus","waitUntilReady","menuRefs","filter","m","side","length","printIonWarning","map","el","sideMenuRefs","find","menuId","_getOpenSync","getMenus","getMenusSync","isAnimating","isAnimatingSync","registerAnimation","name","animation","set","_register","indexOf","push","_unregister","index","splice","_setOpen","shouldOpen","animated","openedMenu","setOpen","_createAnimation","type","menuCmp","animationBuilder","Error","_isOpen","some","predicate","instance","Promise","all","Array","from","document","querySelectorAll","resolve","componentOnReady","doc","addEventListener","ev","openMenu","detail","register","MENU_BACK_BUTTON_PRIORITY","menuController"],"sources":["node_modules/@ionic/core/dist/collection/utils/menu-controller/animations/base.js","node_modules/@ionic/core/dist/collection/utils/menu-controller/animations/overlay.js","node_modules/@ionic/core/dist/collection/utils/menu-controller/animations/push.js","node_modules/@ionic/core/dist/collection/utils/menu-controller/animations/reveal.js","node_modules/@ionic/core/dist/collection/utils/menu-controller/index.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../animation/animation\";\n/**\n * baseAnimation\n * Base class which is extended by the various types. Each\n * type will provide their own animations for open and close\n * and registers itself with Menu.\n */\nexport const baseAnimation = (isIos) => {\n    // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds\n    // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves\n    /**\n     * \"Apply the sharp curve to items temporarily leaving the screen that may return\n     * from the same exit point. When they return, use the deceleration curve. On mobile,\n     * this transition typically occurs over 300ms\" -- MD Motion Guide\n     */\n    return createAnimation().duration(isIos ? 400 : 300);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getIonMode } from \"../../../global/ionic-global\";\nimport { createAnimation } from \"../../animation/animation\";\nimport { baseAnimation } from \"./base\";\n/**\n * Menu Overlay Type\n * The menu slides over the content. The content\n * itself, which is under the menu, does not move.\n */\nexport const menuOverlayAnimation = (menu) => {\n    let closedX;\n    let openedX;\n    const width = menu.width + 8;\n    const menuAnimation = createAnimation();\n    const backdropAnimation = createAnimation();\n    if (menu.isEndSide) {\n        // right side\n        closedX = width + 'px';\n        openedX = '0px';\n    }\n    else {\n        // left side\n        closedX = -width + 'px';\n        openedX = '0px';\n    }\n    menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', `translateX(${closedX})`, `translateX(${openedX})`);\n    const mode = getIonMode(menu);\n    const isIos = mode === 'ios';\n    const opacity = isIos ? 0.2 : 0.25;\n    backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);\n    return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getIonMode } from \"../../../global/ionic-global\";\nimport { createAnimation } from \"../../animation/animation\";\nimport { baseAnimation } from \"./base\";\n/**\n * Menu Push Type\n * The content slides over to reveal the menu underneath.\n * The menu itself also slides over to reveal its bad self.\n */\nexport const menuPushAnimation = (menu) => {\n    let contentOpenedX;\n    let menuClosedX;\n    const mode = getIonMode(menu);\n    const width = menu.width;\n    if (menu.isEndSide) {\n        contentOpenedX = -width + 'px';\n        menuClosedX = width + 'px';\n    }\n    else {\n        contentOpenedX = width + 'px';\n        menuClosedX = -width + 'px';\n    }\n    const menuAnimation = createAnimation()\n        .addElement(menu.menuInnerEl)\n        .fromTo('transform', `translateX(${menuClosedX})`, 'translateX(0px)');\n    const contentAnimation = createAnimation()\n        .addElement(menu.contentEl)\n        .fromTo('transform', 'translateX(0px)', `translateX(${contentOpenedX})`);\n    const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);\n    return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getIonMode } from \"../../../global/ionic-global\";\nimport { createAnimation } from \"../../animation/animation\";\nimport { baseAnimation } from \"./base\";\n/**\n * Menu Reveal Type\n * The content slides over to reveal the menu underneath.\n * The menu itself, which is under the content, does not move.\n */\nexport const menuRevealAnimation = (menu) => {\n    const mode = getIonMode(menu);\n    const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';\n    const contentOpen = createAnimation()\n        .addElement(menu.contentEl) // REVIEW\n        .fromTo('transform', 'translateX(0px)', `translateX(${openedX})`);\n    return baseAnimation(mode === 'ios').addAnimation(contentOpen);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { doc } from \"../browser/index\";\nimport { MENU_BACK_BUTTON_PRIORITY } from \"../hardware-back-button\";\nimport { printIonWarning } from \"../logging/index\";\nimport { componentOnReady } from \"../helpers\";\nimport { menuOverlayAnimation } from \"./animations/overlay\";\nimport { menuPushAnimation } from \"./animations/push\";\nimport { menuRevealAnimation } from \"./animations/reveal\";\nconst createMenuController = () => {\n    const menuAnimations = new Map();\n    const menus = [];\n    const open = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.open();\n        }\n        return false;\n    };\n    const close = async (menu) => {\n        const menuEl = await (menu !== undefined ? get(menu, true) : getOpen());\n        if (menuEl !== undefined) {\n            return menuEl.close();\n        }\n        return false;\n    };\n    const toggle = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.toggle();\n        }\n        return false;\n    };\n    const enable = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.disabled = !shouldEnable;\n        }\n        return menuEl;\n    };\n    const swipeGesture = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.swipeGesture = shouldEnable;\n        }\n        return menuEl;\n    };\n    const isOpen = async (menu) => {\n        if (menu != null) {\n            const menuEl = await get(menu);\n            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n            return menuEl !== undefined && menuEl.isOpen();\n        }\n        else {\n            const menuEl = await getOpen();\n            return menuEl !== undefined;\n        }\n    };\n    const isEnabled = async (menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            return !menuEl.disabled;\n        }\n        return false;\n    };\n    /**\n     * Finds and returns the menu specified by \"menu\" if registered.\n     * @param menu - The side or ID of the desired menu\n     * @param logOnMultipleSideMenus - If true, this function will log a warning\n     * if \"menu\" is a side but multiple menus on the same side were found. Since this function\n     * is used in multiple places, we default this log to false so that the calling\n     * functions can choose whether or not it is appropriate to log this warning.\n     */\n    const get = async (menu, logOnMultipleSideMenus = false) => {\n        await waitUntilReady();\n        if (menu === 'start' || menu === 'end') {\n            // there could be more than one menu on the same side\n            // so first try to get the enabled one\n            const menuRefs = menus.filter((m) => m.side === menu && !m.disabled);\n            if (menuRefs.length >= 1) {\n                if (menuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${menuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, menuRefs.map((m) => m.el));\n                }\n                return menuRefs[0].el;\n            }\n            // didn't find a menu side that is enabled\n            // so try to get the first menu side found\n            const sideMenuRefs = menus.filter((m) => m.side === menu);\n            if (sideMenuRefs.length >= 1) {\n                if (sideMenuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${sideMenuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, sideMenuRefs.map((m) => m.el));\n                }\n                return sideMenuRefs[0].el;\n            }\n        }\n        else if (menu != null) {\n            // the menuId was not left or right\n            // so try to get the menu by its \"id\"\n            return find((m) => m.menuId === menu);\n        }\n        // return the first enabled menu\n        const menuEl = find((m) => !m.disabled);\n        if (menuEl) {\n            return menuEl;\n        }\n        // get the first menu in the array, if one exists\n        return menus.length > 0 ? menus[0].el : undefined;\n    };\n    /**\n     * Get the instance of the opened menu. Returns `null` if a menu is not found.\n     */\n    const getOpen = async () => {\n        await waitUntilReady();\n        return _getOpenSync();\n    };\n    /**\n     * Get all menu instances.\n     */\n    const getMenus = async () => {\n        await waitUntilReady();\n        return getMenusSync();\n    };\n    /**\n     * Get whether or not a menu is animating. Returns `true` if any\n     * menu is currently animating.\n     */\n    const isAnimating = async () => {\n        await waitUntilReady();\n        return isAnimatingSync();\n    };\n    const registerAnimation = (name, animation) => {\n        menuAnimations.set(name, animation);\n    };\n    const _register = (menu) => {\n        if (menus.indexOf(menu) < 0) {\n            menus.push(menu);\n        }\n    };\n    const _unregister = (menu) => {\n        const index = menus.indexOf(menu);\n        if (index > -1) {\n            menus.splice(index, 1);\n        }\n    };\n    const _setOpen = async (menu, shouldOpen, animated) => {\n        if (isAnimatingSync()) {\n            return false;\n        }\n        if (shouldOpen) {\n            const openedMenu = await getOpen();\n            if (openedMenu && menu.el !== openedMenu) {\n                await openedMenu.setOpen(false, false);\n            }\n        }\n        return menu._setOpen(shouldOpen, animated);\n    };\n    const _createAnimation = (type, menuCmp) => {\n        const animationBuilder = menuAnimations.get(type); // TODO(FW-2832): type\n        if (!animationBuilder) {\n            throw new Error('animation not registered');\n        }\n        const animation = animationBuilder(menuCmp);\n        return animation;\n    };\n    const _getOpenSync = () => {\n        return find((m) => m._isOpen);\n    };\n    const getMenusSync = () => {\n        return menus.map((menu) => menu.el);\n    };\n    const isAnimatingSync = () => {\n        return menus.some((menu) => menu.isAnimating);\n    };\n    const find = (predicate) => {\n        const instance = menus.find(predicate);\n        if (instance !== undefined) {\n            return instance.el;\n        }\n        return undefined;\n    };\n    const waitUntilReady = () => {\n        return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map((menu) => new Promise((resolve) => componentOnReady(menu, resolve))));\n    };\n    registerAnimation('reveal', menuRevealAnimation);\n    registerAnimation('push', menuPushAnimation);\n    registerAnimation('overlay', menuOverlayAnimation);\n    doc === null || doc === void 0 ? void 0 : doc.addEventListener('ionBackButton', (ev) => {\n        const openMenu = _getOpenSync();\n        if (openMenu) {\n            ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {\n                return openMenu.close();\n            });\n        }\n    });\n    return {\n        registerAnimation,\n        get,\n        getMenus,\n        getOpen,\n        isEnabled,\n        swipeGesture,\n        isAnimating,\n        isOpen,\n        enable,\n        toggle,\n        close,\n        open,\n        _getOpenSync,\n        _createAnimation,\n        _register,\n        _unregister,\n        _setOpen,\n    };\n};\nexport const menuController = /*@__PURE__*/ createMenuController();\n"],"mappings":";;;GAUO,MAAMA,EAAiBC,GAQnBC,IAAkBC,SAASF,EAAQ,IAAM;;;GCP7C,MAAMG,EAAwBC,IACjC,IAAIC,EACJ,IAAIC,EACJ,MAAMC,EAAQH,EAAKG,MAAQ,EAC3B,MAAMC,EAAgBP,IACtB,MAAMQ,EAAoBR,IAC1B,GAAIG,EAAKM,UAAW,CAEhBL,EAAUE,EAAQ,KAClBD,EAAU,KAClB,KACS,CAEDD,GAAWE,EAAQ,KACnBD,EAAU,KAClB,CACIE,EAAcG,WAAWP,EAAKQ,aAAaC,OAAO,YAAa,cAAcR,KAAY,cAAcC,MACvG,MAAMQ,EAAOC,EAAWX,GACxB,MAAMJ,EAAQc,IAAS,MACvB,MAAME,EAAUhB,EAAQ,GAAM,IAC9BS,EAAkBE,WAAWP,EAAKa,YAAYJ,OAAO,UAAW,IAAMG,GACtE,OAAOjB,EAAcC,GAAOkB,aAAa,CAACV,EAAeC,GAAmB;;;GCrBzE,MAAMU,EAAqBf,IAC9B,IAAIgB,EACJ,IAAIC,EACJ,MAAMP,EAAOC,EAAWX,GACxB,MAAMG,EAAQH,EAAKG,MACnB,GAAIH,EAAKM,UAAW,CAChBU,GAAkBb,EAAQ,KAC1Bc,EAAcd,EAAQ,IAC9B,KACS,CACDa,EAAiBb,EAAQ,KACzBc,GAAed,EAAQ,IAC/B,CACI,MAAMC,EAAgBP,IACjBU,WAAWP,EAAKQ,aAChBC,OAAO,YAAa,cAAcQ,KAAgB,mBACvD,MAAMC,EAAmBrB,IACpBU,WAAWP,EAAKmB,WAChBV,OAAO,YAAa,kBAAmB,cAAcO,MAC1D,MAAMX,EAAoBR,IAAkBU,WAAWP,EAAKa,YAAYJ,OAAO,UAAW,IAAM,KAChG,OAAOd,EAAce,IAAS,OAAOI,aAAa,CAACV,EAAec,EAAkBb,GAAmB;;;GCpBpG,MAAMe,EAAuBpB,IAChC,MAAMU,EAAOC,EAAWX,GACxB,MAAME,EAAUF,EAAKG,OAASH,EAAKM,WAAa,EAAI,GAAK,KACzD,MAAMe,EAAcxB,IACfU,WAAWP,EAAKmB,WAChBV,OAAO,YAAa,kBAAmB,cAAcP,MAC1D,OAAOP,EAAce,IAAS,OAAOI,aAAaO,EAAY;;;GCPlE,MAAMC,EAAuB,KACzB,MAAMC,EAAiB,IAAIC,IAC3B,MAAMC,EAAQ,GACd,MAAMC,EAAOC,MAAO3B,IAChB,MAAM4B,QAAeC,EAAI7B,EAAM,MAC/B,GAAI4B,EAAQ,CACR,OAAOA,EAAOF,MAC1B,CACQ,OAAO,KAAK,EAEhB,MAAMI,EAAQH,MAAO3B,IACjB,MAAM4B,QAAgB5B,IAAS+B,UAAYF,EAAI7B,EAAM,MAAQgC,KAC7D,GAAIJ,IAAWG,UAAW,CACtB,OAAOH,EAAOE,OAC1B,CACQ,OAAO,KAAK,EAEhB,MAAMG,EAASN,MAAO3B,IAClB,MAAM4B,QAAeC,EAAI7B,EAAM,MAC/B,GAAI4B,EAAQ,CACR,OAAOA,EAAOK,QAC1B,CACQ,OAAO,KAAK,EAEhB,MAAMC,EAASP,MAAOQ,EAAcnC,KAChC,MAAM4B,QAAeC,EAAI7B,GACzB,GAAI4B,EAAQ,CACRA,EAAOQ,UAAYD,CAC/B,CACQ,OAAOP,CAAM,EAEjB,MAAMS,EAAeV,MAAOQ,EAAcnC,KACtC,MAAM4B,QAAeC,EAAI7B,GACzB,GAAI4B,EAAQ,CACRA,EAAOS,aAAeF,CAClC,CACQ,OAAOP,CAAM,EAEjB,MAAMU,EAASX,MAAO3B,IAClB,GAAIA,GAAQ,KAAM,CACd,MAAM4B,QAAeC,EAAI7B,GAEzB,OAAO4B,IAAWG,WAAaH,EAAOU,QAClD,KACa,CACD,MAAMV,QAAeI,IACrB,OAAOJ,IAAWG,SAC9B,GAEI,MAAMQ,EAAYZ,MAAO3B,IACrB,MAAM4B,QAAeC,EAAI7B,GACzB,GAAI4B,EAAQ,CACR,OAAQA,EAAOQ,QAC3B,CACQ,OAAO,KAAK,EAUhB,MAAMP,EAAMF,MAAO3B,EAAMwC,EAAyB,eACxCC,IACN,GAAIzC,IAAS,SAAWA,IAAS,MAAO,CAGpC,MAAM0C,EAAWjB,EAAMkB,QAAQC,GAAMA,EAAEC,OAAS7C,IAAS4C,EAAER,WAC3D,GAAIM,EAASI,QAAU,EAAG,CACtB,GAAIJ,EAASI,OAAS,GAAKN,EAAwB,CAC/CO,EAAgB,6CAA6C/C,gBAAmB0C,EAASI,yJAA0JJ,EAASM,KAAKJ,GAAMA,EAAEK,KAC7R,CACgB,OAAOP,EAAS,GAAGO,EACnC,CAGY,MAAMC,EAAezB,EAAMkB,QAAQC,GAAMA,EAAEC,OAAS7C,IACpD,GAAIkD,EAAaJ,QAAU,EAAG,CAC1B,GAAII,EAAaJ,OAAS,GAAKN,EAAwB,CACnDO,EAAgB,6CAA6C/C,gBAAmBkD,EAAaJ,yJAA0JI,EAAaF,KAAKJ,GAAMA,EAAEK,KACrS,CACgB,OAAOC,EAAa,GAAGD,EACvC,CACA,MACa,GAAIjD,GAAQ,KAAM,CAGnB,OAAOmD,GAAMP,GAAMA,EAAEQ,SAAWpD,GAC5C,CAEQ,MAAM4B,EAASuB,GAAMP,IAAOA,EAAER,WAC9B,GAAIR,EAAQ,CACR,OAAOA,CACnB,CAEQ,OAAOH,EAAMqB,OAAS,EAAIrB,EAAM,GAAGwB,GAAKlB,SAAS,EAKrD,MAAMC,EAAUL,gBACNc,IACN,OAAOY,GAAc,EAKzB,MAAMC,EAAW3B,gBACPc,IACN,OAAOc,GAAc,EAMzB,MAAMC,EAAc7B,gBACVc,IACN,OAAOgB,GAAiB,EAE5B,MAAMC,EAAoB,CAACC,EAAMC,KAC7BrC,EAAesC,IAAIF,EAAMC,EAAU,EAEvC,MAAME,EAAa9D,IACf,GAAIyB,EAAMsC,QAAQ/D,GAAQ,EAAG,CACzByB,EAAMuC,KAAKhE,EACvB,GAEI,MAAMiE,EAAejE,IACjB,MAAMkE,EAAQzC,EAAMsC,QAAQ/D,GAC5B,GAAIkE,GAAS,EAAG,CACZzC,EAAM0C,OAAOD,EAAO,EAChC,GAEI,MAAME,EAAWzC,MAAO3B,EAAMqE,EAAYC,KACtC,GAAIb,IAAmB,CACnB,OAAO,KACnB,CACQ,GAAIY,EAAY,CACZ,MAAME,QAAmBvC,IACzB,GAAIuC,GAAcvE,EAAKiD,KAAOsB,EAAY,OAChCA,EAAWC,QAAQ,MAAO,MAChD,CACA,CACQ,OAAOxE,EAAKoE,SAASC,EAAYC,EAAS,EAE9C,MAAMG,EAAmB,CAACC,EAAMC,KAC5B,MAAMC,EAAmBrD,EAAeM,IAAI6C,GAC5C,IAAKE,EAAkB,CACnB,MAAM,IAAIC,MAAM,2BAC5B,CACQ,MAAMjB,EAAYgB,EAAiBD,GACnC,OAAOf,CAAS,EAEpB,MAAMP,EAAe,IACVF,GAAMP,GAAMA,EAAEkC,UAEzB,MAAMvB,EAAe,IACV9B,EAAMuB,KAAKhD,GAASA,EAAKiD,KAEpC,MAAMQ,EAAkB,IACbhC,EAAMsD,MAAM/E,GAASA,EAAKwD,cAErC,MAAML,EAAQ6B,IACV,MAAMC,EAAWxD,EAAM0B,KAAK6B,GAC5B,GAAIC,IAAalD,UAAW,CACxB,OAAOkD,EAAShC,EAC5B,CACQ,OAAOlB,SAAS,EAEpB,MAAMU,EAAiB,IACZyC,QAAQC,IAAIC,MAAMC,KAAKC,SAASC,iBAAiB,aAAavC,KAAKhD,GAAS,IAAIkF,SAASM,GAAYC,EAAiBzF,EAAMwF,QAEvI9B,EAAkB,SAAUtC,GAC5BsC,EAAkB,OAAQ3C,GAC1B2C,EAAkB,UAAW3D,GAC7B2F,IAAQ,MAAQA,SAAa,OAAS,EAAIA,EAAIC,iBAAiB,iBAAkBC,IAC7E,MAAMC,EAAWxC,IACjB,GAAIwC,EAAU,CACVD,EAAGE,OAAOC,SAASC,GAA2B,IACnCH,EAAS/D,SAEhC,KAEI,MAAO,CACH4B,oBACA7B,MACAyB,WACAtB,UACAO,YACAF,eACAmB,cACAlB,SACAJ,SACAD,SACAH,QACAJ,OACA2B,eACAoB,mBACAX,YACAG,cACAG,WACH,EAEO,MAAC6B,EAA+B3E,W"}