{"version":3,"names":["Style","StatusBar","getEngine","capacitor","getCapacitor","isPluginAvailable","Plugins","undefined","setStyle","options","engine","this","getStyle","async","Default","style","getInfo","getBackdropValueForSheet","x","backdropBreakpoint","slope","b","setCardStatusBarDark","win","innerWidth","Dark","setCardStatusBarDefault","defaultStyle","handleCanDismiss","el","animation","canDismiss","shouldDismiss","GESTURE","isRunning","onFinish","dismiss","oneTimeCallback","calculateSpringStep","t","SwipeToCloseDefaults","MIN_PRESENTING_SCALE","createSwipeToCloseGesture","statusBarStyle","onDismiss","DISMISS_THRESHOLD","height","offsetHeight","isOpen","canDismissBlocksGesture","contentEl","scrollEl","canDismissMaxStep","initialScrollY","lastStep","getScrollY","isIonContent","scrollY","canStart","detail","target","event","closest","findClosestIonContent","root","getElementRoot","querySelector","hasRefresherInContent","scrollTop","footer","onStart","deltaY","disableContentScrollY","progressStart","onMove","step","isAttemptingDismissWithCanDismiss","maxStep","processedStep","clampedStep","clamp","progressStep","onEnd","velocity","velocityY","threshold","shouldComplete","newStepValue","easing","getTimeGivenProgression","duration","computeDuration","gesture","enable","resetContentScrollY","progressEnd","createGesture","gestureName","gesturePriority","OVERLAY_GESTURE_PRIORITY","direction","remaining","Math","abs","createSheetEnterAnimation","opts","currentBreakpoint","shouldShowBackdrop","initialBackdrop","backdropAnimation","createAnimation","fromTo","beforeStyles","afterClearStyles","wrapperAnimation","keyframes","offset","opacity","transform","createSheetLeaveAnimation","backdropValue","defaultBackdrop","customBackdrop","createEnterAnimation","iosEnterAnimation","baseEl","presentingEl","addElement","querySelectorAll","baseAnimation","addAnimation","isMobile","window","hasCardModal","tagName","presentingElement","presentingElRoot","presentingAnimation","overflow","bodyEl","document","body","transformOffset","CSS","supports","modalTransform","toPresentingScale","finalTransform","afterStyles","beforeAddWrite","setProperty","filter","borderRadius","shadowAnimation","createLeaveAnimation","iosLeaveAnimation","beforeClearStyles","currentStep","numModals","Array","from","m","length","mdEnterAnimation","mdLeaveAnimation","createSheetGesture","backdropEl","wrapperEl","initialBreakpoint","breakpoints","getCurrentBreakpoint","onBreakpointChange","SheetDefaults","WRAPPER_KEYFRAMES","BACKDROP_KEYFRAMES","clientHeight","childAnimations","find","ani","id","maxBreakpoint","minBreakpoint","enableBackdrop","classList","remove","disableBackdrop","add","shouldEnableBackdrop","raf","focus","initialStep","secondToLastBreakpoint","diff","reduce","a","moveSheetToBreakpoint","breakpoint","breakpointOffset","animated","shouldPreventDismiss","snapToBreakpoint","shouldRemainOpen","Promise","resolve","modalIosCss","IonModalIosStyle0","modalMdCss","IonModalMdStyle0","Modal","constructor","hostRef","lockController","createLockController","triggerController","createTriggerController","coreDelegate","CoreDelegate","isSheetModal","inheritedAttributes","inline","gestureAnimationDismissing","onHandleClick","sheetTransition","handleBehavior","moveToNextBreakpoint","onBackdropTap","BACKDROP","onLifecycle","modalEvent","usersElement","name","LIFECYCLE_MAP","type","ev","CustomEvent","bubbles","cancelable","dispatchEvent","presented","hasController","overlayIndex","delegate","keyboardClose","enterAnimation","leaveAnimation","handle","component","componentProps","cssClass","backdropDismiss","showBackdrop","htmlAttributes","trigger","keepContentsMounted","onIsOpenChange","newValue","oldValue","present","triggerChanged","addClickListener","breakpointsChanged","sortedBreakpoints","sort","connectedCallback","prepareOverlay","disconnectedCallback","removeClickListener","componentWillLoad","attributesToInherit","inheritAttributes","forEach","attribute","attributeValue","Object","assign","includes","printIonWarning","setOverlayId","componentDidLoad","getDelegate","force","workingDelegate","parentEl","parentNode","checkCanDismiss","data","role","unlock","lock","ionMount","emit","attachComponent","hasLazyBuild","deepReady","waitForMount","writeTask","getIonMode","keyboardOpenCallback","addEventListener","KEYBOARD_DID_OPEN","initSheetGesture","initSwipeToClose","_a","animationBuilder","config","get","findIonContent","printIonContentErrorMsg","StatusBarStyle","sheetOnDismiss","ionBreakpointDidChange","removeEventListener","dismissed","detachComponent","destroy","onDidDismiss","eventMethod","onWillDismiss","setCurrentBreakpoint","allowedBreakpoints","currentBreakpointIndex","indexOf","nextBreakpointIndex","nextBreakpoint","render","showHandle","mode","isCardModal","isHandleCycle","h","Host","key","tabindex","zIndex","class","getClassMap","onIonBackdropTap","onIonModalDidPresent","onIonModalWillPresent","onIonModalWillDismiss","onIonModalDidDismiss","ref","visible","tappable","part","tabIndex","onClick","ionModalDidPresent","ionModalWillPresent","ionModalWillDismiss","ionModalDidDismiss"],"sources":["node_modules/@ionic/core/dist/collection/utils/native/status-bar.js","node_modules/@ionic/core/dist/collection/components/modal/utils.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/utils.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/swipe-to-close.js","node_modules/@ionic/core/dist/collection/components/modal/animations/sheet.js","node_modules/@ionic/core/dist/collection/components/modal/animations/ios.enter.js","node_modules/@ionic/core/dist/collection/components/modal/animations/ios.leave.js","node_modules/@ionic/core/dist/collection/components/modal/animations/md.enter.js","node_modules/@ionic/core/dist/collection/components/modal/animations/md.leave.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/sheet.js","node_modules/@ionic/core/dist/collection/components/modal/modal.ios.css?tag=ion-modal&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/modal/modal.md.css?tag=ion-modal&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/modal/modal.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getCapacitor } from \"./capacitor\";\nexport var Style;\n(function (Style) {\n    Style[\"Dark\"] = \"DARK\";\n    Style[\"Light\"] = \"LIGHT\";\n    Style[\"Default\"] = \"DEFAULT\";\n})(Style || (Style = {}));\nexport const StatusBar = {\n    getEngine() {\n        const capacitor = getCapacitor();\n        if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable('StatusBar')) {\n            return capacitor.Plugins.StatusBar;\n        }\n        return undefined;\n    },\n    setStyle(options) {\n        const engine = this.getEngine();\n        if (!engine) {\n            return;\n        }\n        engine.setStyle(options);\n    },\n    getStyle: async function () {\n        const engine = this.getEngine();\n        if (!engine) {\n            return Style.Default;\n        }\n        const { style } = await engine.getInfo();\n        return style;\n    },\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from \"../../utils/browser/index\";\nimport { StatusBar, Style } from \"../../utils/native/status-bar\";\n/**\n * Use y = mx + b to\n * figure out the backdrop value\n * at a particular x coordinate. This\n * is useful when the backdrop does\n * not begin to fade in until after\n * the 0 breakpoint.\n */\nexport const getBackdropValueForSheet = (x, backdropBreakpoint) => {\n    /**\n     * We will use these points:\n     * (backdropBreakpoint, 0)\n     * (maxBreakpoint, 1)\n     * We know that at the beginning breakpoint,\n     * the backdrop will be hidden. We also\n     * know that at the maxBreakpoint, the backdrop\n     * must be fully visible. maxBreakpoint should\n     * always be 1 even if the maximum value\n     * of the breakpoints array is not 1 since\n     * the animation runs from a progress of 0\n     * to a progress of 1.\n     * m = (y2 - y1) / (x2 - x1)\n     *\n     * This is simplified from:\n     * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)\n     *\n     * If the backdropBreakpoint is 1, we return 0 as the\n     * backdrop is completely hidden.\n     *\n     */\n    if (backdropBreakpoint === 1) {\n        return 0;\n    }\n    const slope = 1 / (1 - backdropBreakpoint);\n    /**\n     * From here, compute b which is\n     * the backdrop opacity if the offset\n     * is 0. If the backdrop does not\n     * begin to fade in until after the\n     * 0 breakpoint, this b value will be\n     * negative. This is fine as we never pass\n     * b directly into the animation keyframes.\n     * b = y - mx\n     * Use a known point: (backdropBreakpoint, 0)\n     * This is simplified from:\n     * b = 0 - (backdropBreakpoint * slope)\n     */\n    const b = -(backdropBreakpoint * slope);\n    /**\n     * Finally, we can now determine the\n     * backdrop offset given an arbitrary\n     * gesture offset.\n     */\n    return x * slope + b;\n};\n/**\n * The tablet/desktop card modal activates\n * when the window width is >= 768.\n * At that point, the presenting element\n * is not transformed, so we do not need to\n * adjust the status bar color.\n *\n */\nexport const setCardStatusBarDark = () => {\n    if (!win || win.innerWidth >= 768) {\n        return;\n    }\n    StatusBar.setStyle({ style: Style.Dark });\n};\nexport const setCardStatusBarDefault = (defaultStyle = Style.Default) => {\n    if (!win || win.innerWidth >= 768) {\n        return;\n    }\n    StatusBar.setStyle({ style: defaultStyle });\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { GESTURE } from \"../../../utils/overlays\";\nexport const handleCanDismiss = async (el, animation) => {\n    /**\n     * If canDismiss is not a function\n     * then we can return early. If canDismiss is `true`,\n     * then canDismissBlocksGesture is `false` as canDismiss\n     * will never interrupt the gesture. As a result,\n     * this code block is never reached. If canDismiss is `false`,\n     * then we never dismiss.\n     */\n    if (typeof el.canDismiss !== 'function') {\n        return;\n    }\n    /**\n     * Run the canDismiss callback.\n     * If the function returns `true`,\n     * then we can proceed with dismiss.\n     */\n    const shouldDismiss = await el.canDismiss(undefined, GESTURE);\n    if (!shouldDismiss) {\n        return;\n    }\n    /**\n     * If canDismiss resolved after the snap\n     * back animation finished, we can\n     * dismiss immediately.\n     *\n     * If canDismiss resolved before the snap\n     * back animation finished, we need to\n     * wait until the snap back animation is\n     * done before dismissing.\n     */\n    if (animation.isRunning()) {\n        animation.onFinish(() => {\n            el.dismiss(undefined, 'handler');\n        }, { oneTimeCallback: true });\n    }\n    else {\n        el.dismiss(undefined, 'handler');\n    }\n};\n/**\n * This function lets us simulate a realistic spring-like animation\n * when swiping down on the modal.\n * There are two forces that we need to use to compute the spring physics:\n *\n * 1. Stiffness, k: This is a measure of resistance applied a spring.\n * 2. Dampening, c: This value has the effect of reducing or preventing oscillation.\n *\n * Using these two values, we can calculate the Spring Force and the Dampening Force\n * to compute the total force applied to a spring.\n *\n * Spring Force: This force pulls a spring back into its equilibrium position.\n * Hooke's Law tells us that that spring force (FS) = kX.\n * k is the stiffness of a spring, and X is the displacement of the spring from its\n * equilibrium position. In this case, it is the amount by which the free end\n * of a spring was displaced (stretched/pushed) from its \"relaxed\" position.\n *\n * Dampening Force: This force slows down motion. Without it, a spring would oscillate forever.\n * The dampening force, FD, can be found via this formula: FD = -cv\n * where c the dampening value and v is velocity.\n *\n * Therefore, the resulting force that is exerted on the block is:\n * F = FS + FD = -kX - cv\n *\n * Newton's 2nd Law tells us that F = ma:\n * ma = -kX - cv.\n *\n * For Ionic's purposes, we can assume that m = 1:\n * a = -kX - cv\n *\n * Imagine a block attached to the end of a spring. At equilibrium\n * the block is at position x = 1.\n * Pressing on the block moves it to position x = 0;\n * So, to calculate the displacement, we need to take the\n * current position and subtract the previous position from it.\n * X = x - x0 = 0 - 1 = -1.\n *\n * For Ionic's purposes, we are only pushing on the spring modal\n * so we have a max position of 1.\n * As a result, we can expand displacement to this formula:\n * X = x - 1\n *\n * a = -k(x - 1) - cv\n *\n * We can represent the motion of something as a function of time: f(t) = x.\n * The derivative of position gives us the velocity: f'(t)\n * The derivative of the velocity gives us the acceleration: f''(t)\n *\n * We can substitute the formula above with these values:\n *\n * f\"(t) = -k * (f(t) - 1) - c * f'(t)\n *\n * This is called a differential equation.\n *\n * We know that at t = 0, we are at x = 0 because the modal does not move: f(0) = 0\n * This means our velocity is also zero: f'(0) = 0.\n *\n * We can cheat a bit and plug the formula into Wolfram Alpha.\n * However, we need to pick stiffness and dampening values:\n * k = 0.57\n * c = 15\n *\n * I picked these as they are fairly close to native iOS's spring effect\n * with the modal.\n *\n * What we plug in is this: f(0) = 0; f'(0) = 0; f''(t) = -0.57(f(t) - 1) - 15f'(t)\n *\n * The result is a formula that lets us calculate the acceleration\n * for a given time t.\n * Note: This is the approximate form of the solution. Wolfram Alpha will\n * give you a complex differential equation too.\n */\nexport const calculateSpringStep = (t) => {\n    return 0.00255275 * 2.71828 ** (-14.9619 * t) - 1.00255 * 2.71828 ** (-0.0380968 * t) + 1;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getTimeGivenProgression } from \"../../../utils/animation/cubic-bezier\";\nimport { isIonContent, findClosestIonContent, disableContentScrollY, resetContentScrollY } from \"../../../utils/content/index\";\nimport { createGesture } from \"../../../utils/gesture/index\";\nimport { clamp, getElementRoot } from \"../../../utils/helpers\";\nimport { OVERLAY_GESTURE_PRIORITY } from \"../../../utils/overlays\";\nimport { setCardStatusBarDark, setCardStatusBarDefault } from \"../utils\";\nimport { calculateSpringStep, handleCanDismiss } from \"./utils\";\n// Defaults for the card swipe animation\nexport const SwipeToCloseDefaults = {\n    MIN_PRESENTING_SCALE: 0.915,\n};\nexport const createSwipeToCloseGesture = (el, animation, statusBarStyle, onDismiss) => {\n    /**\n     * The step value at which a card modal\n     * is eligible for dismissing via gesture.\n     */\n    const DISMISS_THRESHOLD = 0.5;\n    const height = el.offsetHeight;\n    let isOpen = false;\n    let canDismissBlocksGesture = false;\n    let contentEl = null;\n    let scrollEl = null;\n    const canDismissMaxStep = 0.2;\n    let initialScrollY = true;\n    let lastStep = 0;\n    const getScrollY = () => {\n        if (contentEl && isIonContent(contentEl)) {\n            return contentEl.scrollY;\n            /**\n             * Custom scroll containers are intended to be\n             * used with virtual scrolling, so we assume\n             * there is scrolling in this case.\n             */\n        }\n        else {\n            return true;\n        }\n    };\n    const canStart = (detail) => {\n        const target = detail.event.target;\n        if (target === null || !target.closest) {\n            return true;\n        }\n        /**\n         * If we are swiping on the content,\n         * swiping should only be possible if\n         * the content is scrolled all the way\n         * to the top so that we do not interfere\n         * with scrolling.\n         *\n         * We cannot assume that the `ion-content`\n         * target will remain consistent between\n         * swipes. For example, when using\n         * ion-nav within a card modal it is\n         * possible to swipe, push a view, and then\n         * swipe again. The target content will not\n         * be the same between swipes.\n         */\n        contentEl = findClosestIonContent(target);\n        if (contentEl) {\n            /**\n             * The card should never swipe to close\n             * on the content with a refresher.\n             * Note: We cannot solve this by making the\n             * swipeToClose gesture have a higher priority\n             * than the refresher gesture as the iOS native\n             * refresh gesture uses a scroll listener in\n             * addition to a gesture.\n             *\n             * Note: Do not use getScrollElement here\n             * because we need this to be a synchronous\n             * operation, and getScrollElement is\n             * asynchronous.\n             */\n            if (isIonContent(contentEl)) {\n                const root = getElementRoot(contentEl);\n                scrollEl = root.querySelector('.inner-scroll');\n            }\n            else {\n                scrollEl = contentEl;\n            }\n            const hasRefresherInContent = !!contentEl.querySelector('ion-refresher');\n            return !hasRefresherInContent && scrollEl.scrollTop === 0;\n        }\n        /**\n         * Card should be swipeable on all\n         * parts of the modal except for the footer.\n         */\n        const footer = target.closest('ion-footer');\n        if (footer === null) {\n            return true;\n        }\n        return false;\n    };\n    const onStart = (detail) => {\n        const { deltaY } = detail;\n        /**\n         * Get the initial scrollY value so\n         * that we can correctly reset the scrollY\n         * prop when the gesture ends.\n         */\n        initialScrollY = getScrollY();\n        /**\n         * If canDismiss is anything other than `true`\n         * then users should be able to swipe down\n         * until a threshold is hit. At that point,\n         * the card modal should not proceed any further.\n         * TODO (FW-937)\n         * Remove undefined check\n         */\n        canDismissBlocksGesture = el.canDismiss !== undefined && el.canDismiss !== true;\n        /**\n         * If we are pulling down, then\n         * it is possible we are pulling on the\n         * content. We do not want scrolling to\n         * happen at the same time as the gesture.\n         */\n        if (deltaY > 0 && contentEl) {\n            disableContentScrollY(contentEl);\n        }\n        animation.progressStart(true, isOpen ? 1 : 0);\n    };\n    const onMove = (detail) => {\n        const { deltaY } = detail;\n        /**\n         * If we are pulling down, then\n         * it is possible we are pulling on the\n         * content. We do not want scrolling to\n         * happen at the same time as the gesture.\n         */\n        if (deltaY > 0 && contentEl) {\n            disableContentScrollY(contentEl);\n        }\n        /**\n         * If we are swiping on the content\n         * then the swipe gesture should only\n         * happen if we are pulling down.\n         *\n         * However, if we pull up and\n         * then down such that the scroll position\n         * returns to 0, we should be able to swipe\n         * the card.\n         */\n        const step = detail.deltaY / height;\n        /**\n         * Check if user is swiping down and\n         * if we have a canDismiss value that\n         * should block the gesture from\n         * proceeding,\n         */\n        const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;\n        /**\n         * If we are blocking the gesture from dismissing,\n         * set the max step value so that the sheet cannot be\n         * completely hidden.\n         */\n        const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n        /**\n         * If we are blocking the gesture from\n         * dismissing, calculate the spring modifier value\n         * this will be added to the starting breakpoint\n         * value to give the gesture a spring-like feeling.\n         * Note that the starting breakpoint is always 0,\n         * so we omit adding 0 to the result.\n         */\n        const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;\n        const clampedStep = clamp(0.0001, processedStep, maxStep);\n        animation.progressStep(clampedStep);\n        /**\n         * When swiping down half way, the status bar style\n         * should be reset to its default value.\n         *\n         * We track lastStep so that we do not fire these\n         * functions on every onMove, only when the user has\n         * crossed a certain threshold.\n         */\n        if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {\n            setCardStatusBarDefault(statusBarStyle);\n            /**\n             * However, if we swipe back up, then the\n             * status bar style should be set to have light\n             * text on a dark background.\n             */\n        }\n        else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {\n            setCardStatusBarDark();\n        }\n        lastStep = clampedStep;\n    };\n    const onEnd = (detail) => {\n        const velocity = detail.velocityY;\n        const step = detail.deltaY / height;\n        const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;\n        const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n        const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;\n        const clampedStep = clamp(0.0001, processedStep, maxStep);\n        const threshold = (detail.deltaY + velocity * 1000) / height;\n        /**\n         * If canDismiss blocks\n         * the swipe gesture, then the\n         * animation can never complete until\n         * canDismiss is checked.\n         */\n        const shouldComplete = !isAttemptingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        if (!shouldComplete) {\n            animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n            newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];\n        }\n        else {\n            animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');\n            newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];\n        }\n        const duration = shouldComplete\n            ? computeDuration(step * height, velocity)\n            : computeDuration((1 - clampedStep) * height, velocity);\n        isOpen = shouldComplete;\n        gesture.enable(false);\n        if (contentEl) {\n            resetContentScrollY(contentEl, initialScrollY);\n        }\n        animation\n            .onFinish(() => {\n            if (!shouldComplete) {\n                gesture.enable(true);\n            }\n        })\n            .progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);\n        /**\n         * If the canDismiss value blocked the gesture\n         * from proceeding, then we should ignore whatever\n         * shouldComplete is. Whether or not the modal\n         * animation should complete is now determined by\n         * canDismiss.\n         *\n         * If the user swiped >25% of the way\n         * to the max step, then we should\n         * check canDismiss. 25% was chosen\n         * to avoid accidental swipes.\n         */\n        if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {\n            handleCanDismiss(el, animation);\n        }\n        else if (shouldComplete) {\n            onDismiss();\n        }\n    };\n    const gesture = createGesture({\n        el,\n        gestureName: 'modalSwipeToClose',\n        gesturePriority: OVERLAY_GESTURE_PRIORITY,\n        direction: 'y',\n        threshold: 10,\n        canStart,\n        onStart,\n        onMove,\n        onEnd,\n    });\n    return gesture;\n};\nconst computeDuration = (remaining, velocity) => {\n    return clamp(400, remaining / Math.abs(velocity * 1.1), 500);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getBackdropValueForSheet } from \"../utils\";\nexport const createSheetEnterAnimation = (opts) => {\n    const { currentBreakpoint, backdropBreakpoint } = opts;\n    /**\n     * If the backdropBreakpoint is undefined, then the backdrop\n     * should always fade in. If the backdropBreakpoint came before the\n     * current breakpoint, then the backdrop should be fading in.\n     */\n    const shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;\n    const initialBackdrop = shouldShowBackdrop ? `calc(var(--backdrop-opacity) * ${currentBreakpoint})` : '0';\n    const backdropAnimation = createAnimation('backdropAnimation').fromTo('opacity', 0, initialBackdrop);\n    if (shouldShowBackdrop) {\n        backdropAnimation\n            .beforeStyles({\n            'pointer-events': 'none',\n        })\n            .afterClearStyles(['pointer-events']);\n    }\n    const wrapperAnimation = createAnimation('wrapperAnimation').keyframes([\n        { offset: 0, opacity: 1, transform: 'translateY(100%)' },\n        { offset: 1, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },\n    ]);\n    return { wrapperAnimation, backdropAnimation };\n};\nexport const createSheetLeaveAnimation = (opts) => {\n    const { currentBreakpoint, backdropBreakpoint } = opts;\n    /**\n     * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint\n     * is defined, so we need to account for that offset by figuring out\n     * what the current backdrop value should be.\n     */\n    const backdropValue = `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint)})`;\n    const defaultBackdrop = [\n        { offset: 0, opacity: backdropValue },\n        { offset: 1, opacity: 0 },\n    ];\n    const customBackdrop = [\n        { offset: 0, opacity: backdropValue },\n        { offset: backdropBreakpoint, opacity: 0 },\n        { offset: 1, opacity: 0 },\n    ];\n    const backdropAnimation = createAnimation('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);\n    const wrapperAnimation = createAnimation('wrapperAnimation').keyframes([\n        { offset: 0, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },\n        { offset: 1, opacity: 1, transform: `translateY(100%)` },\n    ]);\n    return { wrapperAnimation, backdropAnimation };\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { SwipeToCloseDefaults } from \"../gestures/swipe-to-close\";\nimport { createSheetEnterAnimation } from \"./sheet\";\nconst createEnterAnimation = () => {\n    const backdropAnimation = createAnimation()\n        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')\n        .beforeStyles({\n        'pointer-events': 'none',\n    })\n        .afterClearStyles(['pointer-events']);\n    const wrapperAnimation = createAnimation().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');\n    return { backdropAnimation, wrapperAnimation };\n};\n/**\n * iOS Modal Enter Animation for the Card presentation style\n */\nexport const iosEnterAnimation = (baseEl, opts) => {\n    const { presentingEl, currentBreakpoint } = opts;\n    const root = getElementRoot(baseEl);\n    const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation();\n    backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n    wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({ opacity: 1 });\n    const baseAnimation = createAnimation('entering-base')\n        .addElement(baseEl)\n        .easing('cubic-bezier(0.32,0.72,0,1)')\n        .duration(500)\n        .addAnimation(wrapperAnimation);\n    if (presentingEl) {\n        const isMobile = window.innerWidth < 768;\n        const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n        const presentingElRoot = getElementRoot(presentingEl);\n        const presentingAnimation = createAnimation().beforeStyles({\n            transform: 'translateY(0)',\n            'transform-origin': 'top center',\n            overflow: 'hidden',\n        });\n        const bodyEl = document.body;\n        if (isMobile) {\n            /**\n             * Fallback for browsers that does not support `max()` (ex: Firefox)\n             * No need to worry about statusbar padding since engines like Gecko\n             * are not used as the engine for standalone Cordova/Capacitor apps\n             */\n            const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n            const modalTransform = hasCardModal ? '-10px' : transformOffset;\n            const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n            const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;\n            presentingAnimation\n                .afterStyles({\n                transform: finalTransform,\n            })\n                .beforeAddWrite(() => bodyEl.style.setProperty('background-color', 'black'))\n                .addElement(presentingEl)\n                .keyframes([\n                { offset: 0, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },\n                { offset: 1, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },\n            ]);\n            baseAnimation.addAnimation(presentingAnimation);\n        }\n        else {\n            baseAnimation.addAnimation(backdropAnimation);\n            if (!hasCardModal) {\n                wrapperAnimation.fromTo('opacity', '0', '1');\n            }\n            else {\n                const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n                const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;\n                presentingAnimation\n                    .afterStyles({\n                    transform: finalTransform,\n                })\n                    .addElement(presentingElRoot.querySelector('.modal-wrapper'))\n                    .keyframes([\n                    { offset: 0, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },\n                    { offset: 1, filter: 'contrast(0.85)', transform: finalTransform },\n                ]);\n                const shadowAnimation = createAnimation()\n                    .afterStyles({\n                    transform: finalTransform,\n                })\n                    .addElement(presentingElRoot.querySelector('.modal-shadow'))\n                    .keyframes([\n                    { offset: 0, opacity: '1', transform: 'translateY(0) scale(1)' },\n                    { offset: 1, opacity: '0', transform: finalTransform },\n                ]);\n                baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n            }\n        }\n    }\n    else {\n        baseAnimation.addAnimation(backdropAnimation);\n    }\n    return baseAnimation;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { SwipeToCloseDefaults } from \"../gestures/swipe-to-close\";\nimport { createSheetLeaveAnimation } from \"./sheet\";\nconst createLeaveAnimation = () => {\n    const backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n    const wrapperAnimation = createAnimation().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');\n    return { backdropAnimation, wrapperAnimation };\n};\n/**\n * iOS Modal Leave Animation\n */\nexport const iosLeaveAnimation = (baseEl, opts, duration = 500) => {\n    const { presentingEl, currentBreakpoint } = opts;\n    const root = getElementRoot(baseEl);\n    const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation();\n    backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n    wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({ opacity: 1 });\n    const baseAnimation = createAnimation('leaving-base')\n        .addElement(baseEl)\n        .easing('cubic-bezier(0.32,0.72,0,1)')\n        .duration(duration)\n        .addAnimation(wrapperAnimation);\n    if (presentingEl) {\n        const isMobile = window.innerWidth < 768;\n        const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n        const presentingElRoot = getElementRoot(presentingEl);\n        const presentingAnimation = createAnimation()\n            .beforeClearStyles(['transform'])\n            .afterClearStyles(['transform'])\n            .onFinish((currentStep) => {\n            // only reset background color if this is the last card-style modal\n            if (currentStep !== 1) {\n                return;\n            }\n            presentingEl.style.setProperty('overflow', '');\n            const numModals = Array.from(bodyEl.querySelectorAll('ion-modal:not(.overlay-hidden)')).filter((m) => m.presentingElement !== undefined).length;\n            if (numModals <= 1) {\n                bodyEl.style.setProperty('background-color', '');\n            }\n        });\n        const bodyEl = document.body;\n        if (isMobile) {\n            const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n            const modalTransform = hasCardModal ? '-10px' : transformOffset;\n            const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n            const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;\n            presentingAnimation.addElement(presentingEl).keyframes([\n                { offset: 0, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },\n                { offset: 1, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },\n            ]);\n            baseAnimation.addAnimation(presentingAnimation);\n        }\n        else {\n            baseAnimation.addAnimation(backdropAnimation);\n            if (!hasCardModal) {\n                wrapperAnimation.fromTo('opacity', '1', '0');\n            }\n            else {\n                const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n                const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;\n                presentingAnimation\n                    .addElement(presentingElRoot.querySelector('.modal-wrapper'))\n                    .afterStyles({\n                    transform: 'translate3d(0, 0, 0)',\n                })\n                    .keyframes([\n                    { offset: 0, filter: 'contrast(0.85)', transform: finalTransform },\n                    { offset: 1, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },\n                ]);\n                const shadowAnimation = createAnimation()\n                    .addElement(presentingElRoot.querySelector('.modal-shadow'))\n                    .afterStyles({\n                    transform: 'translateY(0) scale(1)',\n                })\n                    .keyframes([\n                    { offset: 0, opacity: '0', transform: finalTransform },\n                    { offset: 1, opacity: '1', transform: 'translateY(0) scale(1)' },\n                ]);\n                baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n            }\n        }\n    }\n    else {\n        baseAnimation.addAnimation(backdropAnimation);\n    }\n    return baseAnimation;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { createSheetEnterAnimation } from \"./sheet\";\nconst createEnterAnimation = () => {\n    const backdropAnimation = createAnimation()\n        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')\n        .beforeStyles({\n        'pointer-events': 'none',\n    })\n        .afterClearStyles(['pointer-events']);\n    const wrapperAnimation = createAnimation().keyframes([\n        { offset: 0, opacity: 0.01, transform: 'translateY(40px)' },\n        { offset: 1, opacity: 1, transform: `translateY(0px)` },\n    ]);\n    return { backdropAnimation, wrapperAnimation };\n};\n/**\n * Md Modal Enter Animation\n */\nexport const mdEnterAnimation = (baseEl, opts) => {\n    const { currentBreakpoint } = opts;\n    const root = getElementRoot(baseEl);\n    const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation();\n    backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n    wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n    return createAnimation()\n        .addElement(baseEl)\n        .easing('cubic-bezier(0.36,0.66,0.04,1)')\n        .duration(280)\n        .addAnimation([backdropAnimation, wrapperAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from \"../../../utils/animation/animation\";\nimport { getElementRoot } from \"../../../utils/helpers\";\nimport { createSheetLeaveAnimation } from \"./sheet\";\nconst createLeaveAnimation = () => {\n    const backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n    const wrapperAnimation = createAnimation().keyframes([\n        { offset: 0, opacity: 0.99, transform: `translateY(0px)` },\n        { offset: 1, opacity: 0, transform: 'translateY(40px)' },\n    ]);\n    return { backdropAnimation, wrapperAnimation };\n};\n/**\n * Md Modal Leave Animation\n */\nexport const mdLeaveAnimation = (baseEl, opts) => {\n    const { currentBreakpoint } = opts;\n    const root = getElementRoot(baseEl);\n    const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation();\n    backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n    wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n    return createAnimation()\n        .easing('cubic-bezier(0.47,0,0.745,0.715)')\n        .duration(200)\n        .addAnimation([backdropAnimation, wrapperAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { isIonContent, findClosestIonContent } from \"../../../utils/content/index\";\nimport { createGesture } from \"../../../utils/gesture/index\";\nimport { clamp, raf, getElementRoot } from \"../../../utils/helpers\";\nimport { getBackdropValueForSheet } from \"../utils\";\nimport { calculateSpringStep, handleCanDismiss } from \"./utils\";\nexport const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation, breakpoints = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {\n    // Defaults for the sheet swipe animation\n    const defaultBackdrop = [\n        { offset: 0, opacity: 'var(--backdrop-opacity)' },\n        { offset: 1, opacity: 0.01 },\n    ];\n    const customBackdrop = [\n        { offset: 0, opacity: 'var(--backdrop-opacity)' },\n        { offset: 1 - backdropBreakpoint, opacity: 0 },\n        { offset: 1, opacity: 0 },\n    ];\n    const SheetDefaults = {\n        WRAPPER_KEYFRAMES: [\n            { offset: 0, transform: 'translateY(0%)' },\n            { offset: 1, transform: 'translateY(100%)' },\n        ],\n        BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop,\n    };\n    const contentEl = baseEl.querySelector('ion-content');\n    const height = wrapperEl.clientHeight;\n    let currentBreakpoint = initialBreakpoint;\n    let offset = 0;\n    let canDismissBlocksGesture = false;\n    const canDismissMaxStep = 0.95;\n    const wrapperAnimation = animation.childAnimations.find((ani) => ani.id === 'wrapperAnimation');\n    const backdropAnimation = animation.childAnimations.find((ani) => ani.id === 'backdropAnimation');\n    const maxBreakpoint = breakpoints[breakpoints.length - 1];\n    const minBreakpoint = breakpoints[0];\n    const enableBackdrop = () => {\n        baseEl.style.setProperty('pointer-events', 'auto');\n        backdropEl.style.setProperty('pointer-events', 'auto');\n        /**\n         * When the backdrop is enabled, elements such\n         * as inputs should not be focusable outside\n         * the sheet.\n         */\n        baseEl.classList.remove('ion-disable-focus-trap');\n    };\n    const disableBackdrop = () => {\n        baseEl.style.setProperty('pointer-events', 'none');\n        backdropEl.style.setProperty('pointer-events', 'none');\n        /**\n         * When the backdrop is enabled, elements such\n         * as inputs should not be focusable outside\n         * the sheet.\n         * Adding this class disables focus trapping\n         * for the sheet temporarily.\n         */\n        baseEl.classList.add('ion-disable-focus-trap');\n    };\n    /**\n     * After the entering animation completes,\n     * we need to set the animation to go from\n     * offset 0 to offset 1 so that users can\n     * swipe in any direction. We then set the\n     * animation offset to the current breakpoint\n     * so there is no flickering.\n     */\n    if (wrapperAnimation && backdropAnimation) {\n        wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);\n        backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);\n        animation.progressStart(true, 1 - currentBreakpoint);\n        /**\n         * If backdrop is not enabled, then content\n         * behind modal should be clickable. To do this, we need\n         * to remove pointer-events from ion-modal as a whole.\n         * ion-backdrop and .modal-wrapper always have pointer-events: auto\n         * applied, so the modal content can still be interacted with.\n         */\n        const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n        if (shouldEnableBackdrop) {\n            enableBackdrop();\n        }\n        else {\n            disableBackdrop();\n        }\n    }\n    if (contentEl && currentBreakpoint !== maxBreakpoint) {\n        contentEl.scrollY = false;\n    }\n    const canStart = (detail) => {\n        /**\n         * If we are swiping on the content, swiping should only be possible if the content\n         * is scrolled all the way to the top so that we do not interfere with scrolling.\n         *\n         * We cannot assume that the `ion-content` target will remain consistent between swipes.\n         * For example, when using ion-nav within a modal it is possible to swipe, push a view,\n         * and then swipe again. The target content will not be the same between swipes.\n         */\n        const contentEl = findClosestIonContent(detail.event.target);\n        currentBreakpoint = getCurrentBreakpoint();\n        if (currentBreakpoint === 1 && contentEl) {\n            /**\n             * The modal should never swipe to close on the content with a refresher.\n             * Note 1: We cannot solve this by making this gesture have a higher priority than\n             * the refresher gesture as the iOS native refresh gesture uses a scroll listener in\n             * addition to a gesture.\n             *\n             * Note 2: Do not use getScrollElement here because we need this to be a synchronous\n             * operation, and getScrollElement is asynchronous.\n             */\n            const scrollEl = isIonContent(contentEl) ? getElementRoot(contentEl).querySelector('.inner-scroll') : contentEl;\n            const hasRefresherInContent = !!contentEl.querySelector('ion-refresher');\n            return !hasRefresherInContent && scrollEl.scrollTop === 0;\n        }\n        return true;\n    };\n    const onStart = (detail) => {\n        /**\n         * If canDismiss is anything other than `true`\n         * then users should be able to swipe down\n         * until a threshold is hit. At that point,\n         * the card modal should not proceed any further.\n         *\n         * canDismiss is never fired via gesture if there is\n         * no 0 breakpoint. However, it can be fired if the user\n         * presses Esc or the hardware back button.\n         * TODO (FW-937)\n         * Remove undefined check\n         */\n        canDismissBlocksGesture = baseEl.canDismiss !== undefined && baseEl.canDismiss !== true && minBreakpoint === 0;\n        /**\n         * If we are pulling down, then it is possible we are pulling on the content.\n         * We do not want scrolling to happen at the same time as the gesture.\n         */\n        if (detail.deltaY > 0 && contentEl) {\n            contentEl.scrollY = false;\n        }\n        raf(() => {\n            /**\n             * Dismisses the open keyboard when the sheet drag gesture is started.\n             * Sets the focus onto the modal element.\n             */\n            baseEl.focus();\n        });\n        animation.progressStart(true, 1 - currentBreakpoint);\n    };\n    const onMove = (detail) => {\n        /**\n         * If we are pulling down, then it is possible we are pulling on the content.\n         * We do not want scrolling to happen at the same time as the gesture.\n         * This accounts for when the user scrolls down, scrolls all the way up, and then\n         * pulls down again such that the modal should start to move.\n         */\n        if (detail.deltaY > 0 && contentEl) {\n            contentEl.scrollY = false;\n        }\n        /**\n         * Given the change in gesture position on the Y axis,\n         * compute where the offset of the animation should be\n         * relative to where the user dragged.\n         */\n        const initialStep = 1 - currentBreakpoint;\n        const secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : undefined;\n        const step = initialStep + detail.deltaY / height;\n        const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== undefined && step >= secondToLastBreakpoint && canDismissBlocksGesture;\n        /**\n         * If we are blocking the gesture from dismissing,\n         * set the max step value so that the sheet cannot be\n         * completely hidden.\n         */\n        const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n        /**\n         * If we are blocking the gesture from\n         * dismissing, calculate the spring modifier value\n         * this will be added to the starting breakpoint\n         * value to give the gesture a spring-like feeling.\n         * Note that when isAttemptingDismissWithCanDismiss is true,\n         * the modifier is always added to the breakpoint that\n         * appears right after the 0 breakpoint.\n         *\n         * Note that this modifier is essentially the progression\n         * between secondToLastBreakpoint and maxStep which is\n         * why we subtract secondToLastBreakpoint. This lets us get\n         * the result as a value from 0 to 1.\n         */\n        const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== undefined\n            ? secondToLastBreakpoint +\n                calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint))\n            : step;\n        offset = clamp(0.0001, processedStep, maxStep);\n        animation.progressStep(offset);\n    };\n    const onEnd = (detail) => {\n        /**\n         * When the gesture releases, we need to determine\n         * the closest breakpoint to snap to.\n         */\n        const velocity = detail.velocityY;\n        const threshold = (detail.deltaY + velocity * 350) / height;\n        const diff = currentBreakpoint - threshold;\n        const closest = breakpoints.reduce((a, b) => {\n            return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;\n        });\n        moveSheetToBreakpoint({\n            breakpoint: closest,\n            breakpointOffset: offset,\n            canDismiss: canDismissBlocksGesture,\n            /**\n             * The swipe is user-driven, so we should\n             * always animate when the gesture ends.\n             */\n            animated: true,\n        });\n    };\n    const moveSheetToBreakpoint = (options) => {\n        const { breakpoint, canDismiss, breakpointOffset, animated } = options;\n        /**\n         * canDismiss should only prevent snapping\n         * when users are trying to dismiss. If canDismiss\n         * is present but the user is trying to swipe upwards,\n         * we should allow that to happen,\n         */\n        const shouldPreventDismiss = canDismiss && breakpoint === 0;\n        const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;\n        const shouldRemainOpen = snapToBreakpoint !== 0;\n        currentBreakpoint = 0;\n        /**\n         * Update the animation so that it plays from\n         * the last offset to the closest snap point.\n         */\n        if (wrapperAnimation && backdropAnimation) {\n            wrapperAnimation.keyframes([\n                { offset: 0, transform: `translateY(${breakpointOffset * 100}%)` },\n                { offset: 1, transform: `translateY(${(1 - snapToBreakpoint) * 100}%)` },\n            ]);\n            backdropAnimation.keyframes([\n                {\n                    offset: 0,\n                    opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint)})`,\n                },\n                {\n                    offset: 1,\n                    opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint)})`,\n                },\n            ]);\n            animation.progressStep(0);\n        }\n        /**\n         * Gesture should remain disabled until the\n         * snapping animation completes.\n         */\n        gesture.enable(false);\n        if (shouldPreventDismiss) {\n            handleCanDismiss(baseEl, animation);\n        }\n        else if (!shouldRemainOpen) {\n            onDismiss();\n        }\n        /**\n         * If the sheet is going to be fully expanded then we should enable\n         * scrolling immediately. The sheet modal animation takes ~500ms to finish\n         * so if we wait until then there is a visible delay for when scrolling is\n         * re-enabled. Native iOS allows for scrolling on the sheet modal as soon\n         * as the gesture is released, so we align with that.\n         */\n        if (contentEl && snapToBreakpoint === breakpoints[breakpoints.length - 1]) {\n            contentEl.scrollY = true;\n        }\n        return new Promise((resolve) => {\n            animation\n                .onFinish(() => {\n                if (shouldRemainOpen) {\n                    /**\n                     * Once the snapping animation completes,\n                     * we need to reset the animation to go\n                     * from 0 to 1 so users can swipe in any direction.\n                     * We then set the animation offset to the current\n                     * breakpoint so that it starts at the snapped position.\n                     */\n                    if (wrapperAnimation && backdropAnimation) {\n                        raf(() => {\n                            wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);\n                            backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);\n                            animation.progressStart(true, 1 - snapToBreakpoint);\n                            currentBreakpoint = snapToBreakpoint;\n                            onBreakpointChange(currentBreakpoint);\n                            /**\n                             * Backdrop should become enabled\n                             * after the backdropBreakpoint value\n                             */\n                            const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n                            if (shouldEnableBackdrop) {\n                                enableBackdrop();\n                            }\n                            else {\n                                disableBackdrop();\n                            }\n                            gesture.enable(true);\n                            resolve();\n                        });\n                    }\n                    else {\n                        gesture.enable(true);\n                        resolve();\n                    }\n                }\n                else {\n                    resolve();\n                }\n                /**\n                 * This must be a one time callback\n                 * otherwise a new callback will\n                 * be added every time onEnd runs.\n                 */\n            }, { oneTimeCallback: true })\n                .progressEnd(1, 0, animated ? 500 : 0);\n        });\n    };\n    const gesture = createGesture({\n        el: wrapperEl,\n        gestureName: 'modalSheet',\n        gesturePriority: 40,\n        direction: 'y',\n        threshold: 10,\n        canStart,\n        onStart,\n        onMove,\n        onEnd,\n    });\n    return {\n        gesture,\n        moveSheetToBreakpoint,\n    };\n};\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the modal content\n   *\n   * @prop --border-color: Border color of the modal content\n   * @prop --border-radius: Border radius of the modal content\n   * @prop --border-width: Border width of the modal content\n   * @prop --border-style: Border style of the modal content\n   *\n   * @prop --min-width: Minimum width of the modal\n   * @prop --width: Width of the modal\n   * @prop --max-width: Maximum width of the modal\n   *\n   * @prop --min-height: Minimum height of the modal\n   * @prop --height: Height of the modal\n   * @prop --max-height: Maximum height of the modal\n   *\n   * @prop --backdrop-opacity: Opacity of the backdrop\n   */\n  --width: 100%;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --overflow: hidden;\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: none;\n  --border-color: transparent;\n  --background: var(--ion-background-color, #fff);\n  --box-shadow: none;\n  --backdrop-opacity: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  position: absolute;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  color: var(--ion-text-color, #000);\n  contain: strict;\n}\n\n.modal-wrapper,\nion-backdrop {\n  pointer-events: auto;\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n.modal-wrapper,\n.modal-shadow {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n  overflow: var(--overflow);\n  z-index: 10;\n}\n\n.modal-shadow {\n  position: absolute;\n  background: transparent;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --width: 600px;\n    --height: 500px;\n    --ion-safe-area-top: 0px;\n    --ion-safe-area-bottom: 0px;\n    --ion-safe-area-right: 0px;\n    --ion-safe-area-left: 0px;\n  }\n}\n@media only screen and (min-width: 768px) and (min-height: 768px) {\n  :host {\n    --width: 600px;\n    --height: 600px;\n  }\n}\n.modal-handle {\n  left: 0px;\n  right: 0px;\n  top: 5px;\n  border-radius: 8px;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  /**\n   * This allows the handle to appear\n   * on top of user content in WebKit.\n   */\n  transform: translateZ(0);\n  border: 0;\n  background: var(--ion-color-step-350, var(--ion-background-color-step-350, #c0c0be));\n  cursor: pointer;\n  z-index: 11;\n}\n.modal-handle::before {\n  /**\n   * Adds a 4px tap area to the perimeter\n   * of the handle.\n   */\n  -webkit-padding-start: 4px;\n  padding-inline-start: 4px;\n  -webkit-padding-end: 4px;\n  padding-inline-end: 4px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  transform: translate(-50%, -50%);\n  content: \"\";\n}\n\n/**\n * Ensure that the sheet modal does not\n * completely cover the content.\n */\n:host(.modal-sheet) {\n  --height: calc(100% - (var(--ion-safe-area-top) + 10px));\n}\n\n:host(.modal-sheet) .modal-wrapper,\n:host(.modal-sheet) .modal-shadow {\n  position: absolute;\n  bottom: 0;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.4);\n}\n\n:host(.modal-card),\n:host(.modal-sheet) {\n  --border-radius: 10px;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --border-radius: 10px;\n  }\n}\n.modal-wrapper {\n  transform: translate3d(0,  100%,  0);\n}\n\n@media screen and (max-width: 767px) {\n  @supports (width: max(0px, 1px)) {\n    :host(.modal-card) {\n      --height: calc(100% - max(30px, var(--ion-safe-area-top)) - 10px);\n    }\n  }\n  @supports not (width: max(0px, 1px)) {\n    :host(.modal-card) {\n      --height: calc(100% - 40px);\n    }\n  }\n  :host(.modal-card) .modal-wrapper {\n    border-start-start-radius: var(--border-radius);\n    border-start-end-radius: var(--border-radius);\n    border-end-end-radius: 0;\n    border-end-start-radius: 0;\n  }\n  :host(.modal-card) {\n    --backdrop-opacity: 0;\n    --width: 100%;\n    align-items: flex-end;\n  }\n  :host(.modal-card) .modal-shadow {\n    display: none;\n  }\n  :host(.modal-card) ion-backdrop {\n    pointer-events: none;\n  }\n}\n@media screen and (min-width: 768px) {\n  :host(.modal-card) {\n    --width: calc(100% - 120px);\n    --height: calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));\n    --max-width: 720px;\n    --max-height: 1000px;\n    --backdrop-opacity: 0;\n    --box-shadow: 0px 0px 30px 10px rgba(0, 0, 0, 0.1);\n    transition: all 0.5s ease-in-out;\n  }\n  :host(.modal-card) .modal-wrapper {\n    box-shadow: none;\n  }\n  :host(.modal-card) .modal-shadow {\n    box-shadow: var(--box-shadow);\n  }\n}\n:host(.modal-sheet) .modal-wrapper {\n  border-start-start-radius: var(--border-radius);\n  border-start-end-radius: var(--border-radius);\n  border-end-end-radius: 0;\n  border-end-start-radius: 0;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the modal content\n   *\n   * @prop --border-color: Border color of the modal content\n   * @prop --border-radius: Border radius of the modal content\n   * @prop --border-width: Border width of the modal content\n   * @prop --border-style: Border style of the modal content\n   *\n   * @prop --min-width: Minimum width of the modal\n   * @prop --width: Width of the modal\n   * @prop --max-width: Maximum width of the modal\n   *\n   * @prop --min-height: Minimum height of the modal\n   * @prop --height: Height of the modal\n   * @prop --max-height: Maximum height of the modal\n   *\n   * @prop --backdrop-opacity: Opacity of the backdrop\n   */\n  --width: 100%;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --overflow: hidden;\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: none;\n  --border-color: transparent;\n  --background: var(--ion-background-color, #fff);\n  --box-shadow: none;\n  --backdrop-opacity: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  position: absolute;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  color: var(--ion-text-color, #000);\n  contain: strict;\n}\n\n.modal-wrapper,\nion-backdrop {\n  pointer-events: auto;\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n.modal-wrapper,\n.modal-shadow {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n  overflow: var(--overflow);\n  z-index: 10;\n}\n\n.modal-shadow {\n  position: absolute;\n  background: transparent;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --width: 600px;\n    --height: 500px;\n    --ion-safe-area-top: 0px;\n    --ion-safe-area-bottom: 0px;\n    --ion-safe-area-right: 0px;\n    --ion-safe-area-left: 0px;\n  }\n}\n@media only screen and (min-width: 768px) and (min-height: 768px) {\n  :host {\n    --width: 600px;\n    --height: 600px;\n  }\n}\n.modal-handle {\n  left: 0px;\n  right: 0px;\n  top: 5px;\n  border-radius: 8px;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  /**\n   * This allows the handle to appear\n   * on top of user content in WebKit.\n   */\n  transform: translateZ(0);\n  border: 0;\n  background: var(--ion-color-step-350, var(--ion-background-color-step-350, #c0c0be));\n  cursor: pointer;\n  z-index: 11;\n}\n.modal-handle::before {\n  /**\n   * Adds a 4px tap area to the perimeter\n   * of the handle.\n   */\n  -webkit-padding-start: 4px;\n  padding-inline-start: 4px;\n  -webkit-padding-end: 4px;\n  padding-inline-end: 4px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  transform: translate(-50%, -50%);\n  content: \"\";\n}\n\n/**\n * Ensure that the sheet modal does not\n * completely cover the content.\n */\n:host(.modal-sheet) {\n  --height: calc(100% - (var(--ion-safe-area-top) + 10px));\n}\n\n:host(.modal-sheet) .modal-wrapper,\n:host(.modal-sheet) .modal-shadow {\n  position: absolute;\n  bottom: 0;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.32);\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --border-radius: 2px;\n    --box-shadow: 0 28px 48px rgba(0, 0, 0, 0.4);\n  }\n}\n.modal-wrapper {\n  transform: translate3d(0,  40px,  0);\n  opacity: 0.01;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h, writeTask } from \"@stencil/core\";\nimport { findIonContent, printIonContentErrorMsg } from \"../../utils/content/index\";\nimport { CoreDelegate, attachComponent, detachComponent } from \"../../utils/framework-delegate\";\nimport { raf, inheritAttributes, hasLazyBuild } from \"../../utils/helpers\";\nimport { createLockController } from \"../../utils/lock-controller\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { Style as StatusBarStyle, StatusBar } from \"../../utils/native/status-bar\";\nimport { GESTURE, BACKDROP, dismiss, eventMethod, prepareOverlay, present, createTriggerController, setOverlayId, } from \"../../utils/overlays\";\nimport { getClassMap } from \"../../utils/theme\";\nimport { deepReady, waitForMount } from \"../../utils/transition/index\";\nimport { config } from \"../../global/config\";\nimport { getIonMode } from \"../../global/ionic-global\";\nimport { KEYBOARD_DID_OPEN } from \"../../utils/keyboard/keyboard\";\nimport { iosEnterAnimation } from \"./animations/ios.enter\";\nimport { iosLeaveAnimation } from \"./animations/ios.leave\";\nimport { mdEnterAnimation } from \"./animations/md.enter\";\nimport { mdLeaveAnimation } from \"./animations/md.leave\";\nimport { createSheetGesture } from \"./gestures/sheet\";\nimport { createSwipeToCloseGesture } from \"./gestures/swipe-to-close\";\nimport { setCardStatusBarDark, setCardStatusBarDefault } from \"./utils\";\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot - Content is placed inside of the `.modal-content` element.\n *\n * @part backdrop - The `ion-backdrop` element.\n * @part content - The wrapper element for the default slot.\n * @part handle - The handle that is displayed at the top of the sheet modal when `handle=\"true\"`.\n */\nexport class Modal {\n    constructor() {\n        this.lockController = createLockController();\n        this.triggerController = createTriggerController();\n        this.coreDelegate = CoreDelegate();\n        this.isSheetModal = false;\n        this.inheritedAttributes = {};\n        this.inline = false;\n        // Whether or not modal is being dismissed via gesture\n        this.gestureAnimationDismissing = false;\n        this.onHandleClick = () => {\n            const { sheetTransition, handleBehavior } = this;\n            if (handleBehavior !== 'cycle' || sheetTransition !== undefined) {\n                /**\n                 * The sheet modal should not advance to the next breakpoint\n                 * if the handle behavior is not `cycle` or if the handle\n                 * is clicked while the sheet is moving to a breakpoint.\n                 */\n                return;\n            }\n            this.moveToNextBreakpoint();\n        };\n        this.onBackdropTap = () => {\n            const { sheetTransition } = this;\n            if (sheetTransition !== undefined) {\n                /**\n                 * When the handle is double clicked at the largest breakpoint,\n                 * it will start to move to the first breakpoint. While transitioning,\n                 * the backdrop will often receive the second click. We prevent the\n                 * backdrop from dismissing the modal while moving between breakpoints.\n                 */\n                return;\n            }\n            this.dismiss(undefined, BACKDROP);\n        };\n        this.onLifecycle = (modalEvent) => {\n            const el = this.usersElement;\n            const name = LIFECYCLE_MAP[modalEvent.type];\n            if (el && name) {\n                const ev = new CustomEvent(name, {\n                    bubbles: false,\n                    cancelable: false,\n                    detail: modalEvent.detail,\n                });\n                el.dispatchEvent(ev);\n            }\n        };\n        this.presented = false;\n        this.hasController = false;\n        this.overlayIndex = undefined;\n        this.delegate = undefined;\n        this.keyboardClose = true;\n        this.enterAnimation = undefined;\n        this.leaveAnimation = undefined;\n        this.breakpoints = undefined;\n        this.initialBreakpoint = undefined;\n        this.backdropBreakpoint = 0;\n        this.handle = undefined;\n        this.handleBehavior = 'none';\n        this.component = undefined;\n        this.componentProps = undefined;\n        this.cssClass = undefined;\n        this.backdropDismiss = true;\n        this.showBackdrop = true;\n        this.animated = true;\n        this.presentingElement = undefined;\n        this.htmlAttributes = undefined;\n        this.isOpen = false;\n        this.trigger = undefined;\n        this.keepContentsMounted = false;\n        this.canDismiss = true;\n    }\n    onIsOpenChange(newValue, oldValue) {\n        if (newValue === true && oldValue === false) {\n            this.present();\n        }\n        else if (newValue === false && oldValue === true) {\n            this.dismiss();\n        }\n    }\n    triggerChanged() {\n        const { trigger, el, triggerController } = this;\n        if (trigger) {\n            triggerController.addClickListener(el, trigger);\n        }\n    }\n    breakpointsChanged(breakpoints) {\n        if (breakpoints !== undefined) {\n            this.sortedBreakpoints = breakpoints.sort((a, b) => a - b);\n        }\n    }\n    connectedCallback() {\n        const { el } = this;\n        prepareOverlay(el);\n        this.triggerChanged();\n    }\n    disconnectedCallback() {\n        this.triggerController.removeClickListener();\n    }\n    componentWillLoad() {\n        const { breakpoints, initialBreakpoint, el, htmlAttributes } = this;\n        const isSheetModal = (this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined);\n        const attributesToInherit = ['aria-label', 'role'];\n        this.inheritedAttributes = inheritAttributes(el, attributesToInherit);\n        /**\n         * When using a controller modal you can set attributes\n         * using the htmlAttributes property. Since the above attributes\n         * need to be inherited inside of the modal, we need to look\n         * and see if these attributes are being set via htmlAttributes.\n         *\n         * We could alternatively move this to componentDidLoad to simplify the work\n         * here, but we'd then need to make inheritedAttributes a State variable,\n         * thus causing another render to always happen after the first render.\n         */\n        if (htmlAttributes !== undefined) {\n            attributesToInherit.forEach((attribute) => {\n                const attributeValue = htmlAttributes[attribute];\n                if (attributeValue) {\n                    /**\n                     * If an attribute we need to inherit was\n                     * set using htmlAttributes then add it to\n                     * inheritedAttributes and remove it from htmlAttributes.\n                     * This ensures the attribute is inherited and not\n                     * set on the host.\n                     *\n                     * In this case, if an inherited attribute is set\n                     * on the host element and using htmlAttributes then\n                     * htmlAttributes wins, but that's not a pattern that we recommend.\n                     * The only time you'd need htmlAttributes is when using modalController.\n                     */\n                    this.inheritedAttributes = Object.assign(Object.assign({}, this.inheritedAttributes), { [attribute]: htmlAttributes[attribute] });\n                    delete htmlAttributes[attribute];\n                }\n            });\n        }\n        if (isSheetModal) {\n            this.currentBreakpoint = this.initialBreakpoint;\n        }\n        if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {\n            printIonWarning('Your breakpoints array must include the initialBreakpoint value.');\n        }\n        setOverlayId(el);\n    }\n    componentDidLoad() {\n        /**\n         * If modal was rendered with isOpen=\"true\"\n         * then we should open modal immediately.\n         */\n        if (this.isOpen === true) {\n            raf(() => this.present());\n        }\n        this.breakpointsChanged(this.breakpoints);\n        /**\n         * When binding values in frameworks such as Angular\n         * it is possible for the value to be set after the Web Component\n         * initializes but before the value watcher is set up in Stencil.\n         * As a result, the watcher callback may not be fired.\n         * We work around this by manually calling the watcher\n         * callback when the component has loaded and the watcher\n         * is configured.\n         */\n        this.triggerChanged();\n    }\n    /**\n     * Determines whether or not an overlay\n     * is being used inline or via a controller/JS\n     * and returns the correct delegate.\n     * By default, subsequent calls to getDelegate\n     * will use a cached version of the delegate.\n     * This is useful for calling dismiss after\n     * present so that the correct delegate is given.\n     */\n    getDelegate(force = false) {\n        if (this.workingDelegate && !force) {\n            return {\n                delegate: this.workingDelegate,\n                inline: this.inline,\n            };\n        }\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = this.el.parentNode;\n        const inline = (this.inline = parentEl !== null && !this.hasController);\n        const delegate = (this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate);\n        return { inline, delegate };\n    }\n    /**\n     * Determines whether or not the\n     * modal is allowed to dismiss based\n     * on the state of the canDismiss prop.\n     */\n    async checkCanDismiss(data, role) {\n        const { canDismiss } = this;\n        if (typeof canDismiss === 'function') {\n            return canDismiss(data, role);\n        }\n        return canDismiss;\n    }\n    /**\n     * Present the modal overlay after it has been created.\n     */\n    async present() {\n        const unlock = await this.lockController.lock();\n        if (this.presented) {\n            unlock();\n            return;\n        }\n        const { presentingElement, el } = this;\n        /**\n         * If the modal is presented multiple times (inline modals), we\n         * need to reset the current breakpoint to the initial breakpoint.\n         */\n        this.currentBreakpoint = this.initialBreakpoint;\n        const { inline, delegate } = this.getDelegate(true);\n        /**\n         * Emit ionMount so JS Frameworks have an opportunity\n         * to add the child component to the DOM. The child\n         * component will be assigned to this.usersElement below.\n         */\n        this.ionMount.emit();\n        this.usersElement = await attachComponent(delegate, el, this.component, ['ion-page'], this.componentProps, inline);\n        /**\n         * When using the lazy loaded build of Stencil, we need to wait\n         * for every Stencil component instance to be ready before presenting\n         * otherwise there can be a flash of unstyled content. With the\n         * custom elements bundle we need to wait for the JS framework\n         * mount the inner contents of the overlay otherwise WebKit may\n         * get the transition incorrect.\n         */\n        if (hasLazyBuild(el)) {\n            await deepReady(this.usersElement);\n            /**\n             * If keepContentsMounted=\"true\" then the\n             * JS Framework has already mounted the inner\n             * contents so there is no need to wait.\n             * Otherwise, we need to wait for the JS\n             * Framework to mount the inner contents\n             * of this component.\n             */\n        }\n        else if (!this.keepContentsMounted) {\n            await waitForMount();\n        }\n        writeTask(() => this.el.classList.add('show-modal'));\n        const hasCardModal = presentingElement !== undefined;\n        /**\n         * We need to change the status bar at the\n         * start of the animation so that it completes\n         * by the time the card animation is done.\n         */\n        if (hasCardModal && getIonMode(this) === 'ios') {\n            // Cache the original status bar color before the modal is presented\n            this.statusBarStyle = await StatusBar.getStyle();\n            setCardStatusBarDark();\n        }\n        await present(this, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {\n            presentingEl: presentingElement,\n            currentBreakpoint: this.initialBreakpoint,\n            backdropBreakpoint: this.backdropBreakpoint,\n        });\n        /* tslint:disable-next-line */\n        if (typeof window !== 'undefined') {\n            /**\n             * This needs to be setup before any\n             * non-transition async work so it can be dereferenced\n             * in the dismiss method. The dismiss method\n             * only waits for the entering transition\n             * to finish. It does not wait for all of the `present`\n             * method to resolve.\n             */\n            this.keyboardOpenCallback = () => {\n                if (this.gesture) {\n                    /**\n                     * When the native keyboard is opened and the webview\n                     * is resized, the gesture implementation will become unresponsive\n                     * and enter a free-scroll mode.\n                     *\n                     * When the keyboard is opened, we disable the gesture for\n                     * a single frame and re-enable once the contents have repositioned\n                     * from the keyboard placement.\n                     */\n                    this.gesture.enable(false);\n                    raf(() => {\n                        if (this.gesture) {\n                            this.gesture.enable(true);\n                        }\n                    });\n                }\n            };\n            window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n        }\n        if (this.isSheetModal) {\n            this.initSheetGesture();\n        }\n        else if (hasCardModal) {\n            this.initSwipeToClose();\n        }\n        unlock();\n    }\n    initSwipeToClose() {\n        var _a;\n        if (getIonMode(this) !== 'ios') {\n            return;\n        }\n        const { el } = this;\n        // All of the elements needed for the swipe gesture\n        // should be in the DOM and referenced by now, except\n        // for the presenting el\n        const animationBuilder = this.leaveAnimation || config.get('modalLeave', iosLeaveAnimation);\n        const ani = (this.animation = animationBuilder(el, { presentingEl: this.presentingElement }));\n        const contentEl = findIonContent(el);\n        if (!contentEl) {\n            printIonContentErrorMsg(el);\n            return;\n        }\n        const statusBarStyle = (_a = this.statusBarStyle) !== null && _a !== void 0 ? _a : StatusBarStyle.Default;\n        this.gesture = createSwipeToCloseGesture(el, ani, statusBarStyle, () => {\n            /**\n             * While the gesture animation is finishing\n             * it is possible for a user to tap the backdrop.\n             * This would result in the dismiss animation\n             * being played again. Typically this is avoided\n             * by setting `presented = false` on the overlay\n             * component; however, we cannot do that here as\n             * that would prevent the element from being\n             * removed from the DOM.\n             */\n            this.gestureAnimationDismissing = true;\n            /**\n             * Reset the status bar style as the dismiss animation\n             * starts otherwise the status bar will be the wrong\n             * color for the duration of the dismiss animation.\n             * The dismiss method does this as well, but\n             * in this case it's only called once the animation\n             * has finished.\n             */\n            setCardStatusBarDefault(this.statusBarStyle);\n            this.animation.onFinish(async () => {\n                await this.dismiss(undefined, GESTURE);\n                this.gestureAnimationDismissing = false;\n            });\n        });\n        this.gesture.enable(true);\n    }\n    initSheetGesture() {\n        const { wrapperEl, initialBreakpoint, backdropBreakpoint } = this;\n        if (!wrapperEl || initialBreakpoint === undefined) {\n            return;\n        }\n        const animationBuilder = this.enterAnimation || config.get('modalEnter', iosEnterAnimation);\n        const ani = (this.animation = animationBuilder(this.el, {\n            presentingEl: this.presentingElement,\n            currentBreakpoint: initialBreakpoint,\n            backdropBreakpoint,\n        }));\n        ani.progressStart(true, 1);\n        const { gesture, moveSheetToBreakpoint } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => { var _a; return (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : 0; }, () => this.sheetOnDismiss(), (breakpoint) => {\n            if (this.currentBreakpoint !== breakpoint) {\n                this.currentBreakpoint = breakpoint;\n                this.ionBreakpointDidChange.emit({ breakpoint });\n            }\n        });\n        this.gesture = gesture;\n        this.moveSheetToBreakpoint = moveSheetToBreakpoint;\n        this.gesture.enable(true);\n    }\n    sheetOnDismiss() {\n        /**\n         * While the gesture animation is finishing\n         * it is possible for a user to tap the backdrop.\n         * This would result in the dismiss animation\n         * being played again. Typically this is avoided\n         * by setting `presented = false` on the overlay\n         * component; however, we cannot do that here as\n         * that would prevent the element from being\n         * removed from the DOM.\n         */\n        this.gestureAnimationDismissing = true;\n        this.animation.onFinish(async () => {\n            this.currentBreakpoint = 0;\n            this.ionBreakpointDidChange.emit({ breakpoint: this.currentBreakpoint });\n            await this.dismiss(undefined, GESTURE);\n            this.gestureAnimationDismissing = false;\n        });\n    }\n    /**\n     * Dismiss the modal overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\n     *\n     * This is a no-op if the overlay has not been presented yet. If you want\n     * to remove an overlay from the DOM that was never presented, use the\n     * [remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\n     */\n    async dismiss(data, role) {\n        var _a;\n        if (this.gestureAnimationDismissing && role !== GESTURE) {\n            return false;\n        }\n        /**\n         * Because the canDismiss check below is async,\n         * we need to claim a lock before the check happens,\n         * in case the dismiss transition does run.\n         */\n        const unlock = await this.lockController.lock();\n        /**\n         * If a canDismiss handler is responsible\n         * for calling the dismiss method, we should\n         * not run the canDismiss check again.\n         */\n        if (role !== 'handler' && !(await this.checkCanDismiss(data, role))) {\n            unlock();\n            return false;\n        }\n        const { presentingElement } = this;\n        /**\n         * We need to start the status bar change\n         * before the animation so that the change\n         * finishes when the dismiss animation does.\n         */\n        const hasCardModal = presentingElement !== undefined;\n        if (hasCardModal && getIonMode(this) === 'ios') {\n            setCardStatusBarDefault(this.statusBarStyle);\n        }\n        /* tslint:disable-next-line */\n        if (typeof window !== 'undefined' && this.keyboardOpenCallback) {\n            window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n            this.keyboardOpenCallback = undefined;\n        }\n        const dismissed = await dismiss(this, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {\n            presentingEl: presentingElement,\n            currentBreakpoint: (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : this.initialBreakpoint,\n            backdropBreakpoint: this.backdropBreakpoint,\n        });\n        if (dismissed) {\n            const { delegate } = this.getDelegate();\n            await detachComponent(delegate, this.usersElement);\n            writeTask(() => this.el.classList.remove('show-modal'));\n            if (this.animation) {\n                this.animation.destroy();\n            }\n            if (this.gesture) {\n                this.gesture.destroy();\n            }\n        }\n        this.currentBreakpoint = undefined;\n        this.animation = undefined;\n        unlock();\n        return dismissed;\n    }\n    /**\n     * Returns a promise that resolves when the modal did dismiss.\n     */\n    onDidDismiss() {\n        return eventMethod(this.el, 'ionModalDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the modal will dismiss.\n     */\n    onWillDismiss() {\n        return eventMethod(this.el, 'ionModalWillDismiss');\n    }\n    /**\n     * Move a sheet style modal to a specific breakpoint. The breakpoint value must\n     * be a value defined in your `breakpoints` array.\n     */\n    async setCurrentBreakpoint(breakpoint) {\n        if (!this.isSheetModal) {\n            printIonWarning('setCurrentBreakpoint is only supported on sheet modals.');\n            return;\n        }\n        if (!this.breakpoints.includes(breakpoint)) {\n            printIonWarning(`Attempted to set invalid breakpoint value ${breakpoint}. Please double check that the breakpoint value is part of your defined breakpoints.`);\n            return;\n        }\n        const { currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints, animated } = this;\n        if (currentBreakpoint === breakpoint) {\n            return;\n        }\n        if (moveSheetToBreakpoint) {\n            this.sheetTransition = moveSheetToBreakpoint({\n                breakpoint,\n                breakpointOffset: 1 - currentBreakpoint,\n                canDismiss: canDismiss !== undefined && canDismiss !== true && breakpoints[0] === 0,\n                animated,\n            });\n            await this.sheetTransition;\n            this.sheetTransition = undefined;\n        }\n    }\n    /**\n     * Returns the current breakpoint of a sheet style modal\n     */\n    async getCurrentBreakpoint() {\n        return this.currentBreakpoint;\n    }\n    async moveToNextBreakpoint() {\n        const { breakpoints, currentBreakpoint } = this;\n        if (!breakpoints || currentBreakpoint == null) {\n            /**\n             * If the modal does not have breakpoints and/or the current\n             * breakpoint is not set, we can't move to the next breakpoint.\n             */\n            return false;\n        }\n        const allowedBreakpoints = breakpoints.filter((b) => b !== 0);\n        const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);\n        const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;\n        const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];\n        /**\n         * Sets the current breakpoint to the next available breakpoint.\n         * If the current breakpoint is the last breakpoint, we set the current\n         * breakpoint to the first non-zero breakpoint to avoid dismissing the sheet.\n         */\n        await this.setCurrentBreakpoint(nextBreakpoint);\n        return true;\n    }\n    render() {\n        const { handle, isSheetModal, presentingElement, htmlAttributes, handleBehavior, inheritedAttributes } = this;\n        const showHandle = handle !== false && isSheetModal;\n        const mode = getIonMode(this);\n        const isCardModal = presentingElement !== undefined && mode === 'ios';\n        const isHandleCycle = handleBehavior === 'cycle';\n        return (h(Host, Object.assign({ key: 'bb00efb8cbbdb2d1bbcc5e9c638586e2904882a8', \"no-router\": true, tabindex: \"-1\" }, htmlAttributes, { style: {\n                zIndex: `${20000 + this.overlayIndex}`,\n            }, class: Object.assign({ [mode]: true, ['modal-default']: !isCardModal && !isSheetModal, [`modal-card`]: isCardModal, [`modal-sheet`]: isSheetModal, 'overlay-hidden': true }, getClassMap(this.cssClass)), onIonBackdropTap: this.onBackdropTap, onIonModalDidPresent: this.onLifecycle, onIonModalWillPresent: this.onLifecycle, onIonModalWillDismiss: this.onLifecycle, onIonModalDidDismiss: this.onLifecycle }), h(\"ion-backdrop\", { key: 'd2d50f736fdc34b933c00309fe0b67e4aff7ee63', ref: (el) => (this.backdropEl = el), visible: this.showBackdrop, tappable: this.backdropDismiss, part: \"backdrop\" }), mode === 'ios' && h(\"div\", { key: '5d3523a04da9350ae435a4f3247198095b71f206', class: \"modal-shadow\" }), h(\"div\", Object.assign({ key: '09b3c4b629155f8c32f5c896cf689ffbe7004de8',\n            /*\n              role and aria-modal must be used on the\n              same element. They must also be set inside the\n              shadow DOM otherwise ion-button will not be highlighted\n              when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134\n            */\n            role: \"dialog\" }, inheritedAttributes, { \"aria-modal\": \"true\", class: \"modal-wrapper ion-overlay-wrapper\", part: \"content\", ref: (el) => (this.wrapperEl = el) }), showHandle && (h(\"button\", { key: 'e47d90068927f3a518e4144e17f18ac326126712', class: \"modal-handle\",\n            // Prevents the handle from receiving keyboard focus when it does not cycle\n            tabIndex: !isHandleCycle ? -1 : 0, \"aria-label\": \"Activate to adjust the size of the dialog overlaying the screen\", onClick: isHandleCycle ? this.onHandleClick : undefined, part: \"handle\" })), h(\"slot\", { key: '5733e94b3ecc4ed9bfb6aec5cd254cd0e43ee8f7' }))));\n    }\n    static get is() { return \"ion-modal\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"modal.ios.scss\"],\n            \"md\": [\"modal.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"modal.ios.css\"],\n            \"md\": [\"modal.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"hasController\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                },\n                \"attribute\": \"has-controller\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"overlayIndex\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": true,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                },\n                \"attribute\": \"overlay-index\",\n                \"reflect\": false\n            },\n            \"delegate\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"FrameworkDelegate\",\n                    \"resolved\": \"FrameworkDelegate | undefined\",\n                    \"references\": {\n                        \"FrameworkDelegate\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::FrameworkDelegate\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"\"\n                }\n            },\n            \"keyboardClose\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the keyboard will be automatically dismissed when the overlay is presented.\"\n                },\n                \"attribute\": \"keyboard-close\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"enterAnimation\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"AnimationBuilder\",\n                    \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n                    \"references\": {\n                        \"AnimationBuilder\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::AnimationBuilder\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Animation to use when the modal is presented.\"\n                }\n            },\n            \"leaveAnimation\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"AnimationBuilder\",\n                    \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n                    \"references\": {\n                        \"AnimationBuilder\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::AnimationBuilder\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Animation to use when the modal is dismissed.\"\n                }\n            },\n            \"breakpoints\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number[]\",\n                    \"resolved\": \"number[] | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The breakpoints to use when creating a sheet modal. Each value in the\\narray must be a decimal between 0 and 1 where 0 indicates the modal is fully\\nclosed and 1 indicates the modal is fully open. Values are relative\\nto the height of the modal, not the height of the screen. One of the values in this\\narray must be the value of the `initialBreakpoint` property.\\nFor example: [0, .25, .5, 1]\"\n                }\n            },\n            \"initialBreakpoint\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"A decimal value between 0 and 1 that indicates the\\ninitial point the modal will open at when creating a\\nsheet modal. This value must also be listed in the\\n`breakpoints` array.\"\n                },\n                \"attribute\": \"initial-breakpoint\",\n                \"reflect\": false\n            },\n            \"backdropBreakpoint\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"A decimal value between 0 and 1 that indicates the\\npoint after which the backdrop will begin to fade in\\nwhen using a sheet modal. Prior to this point, the\\nbackdrop will be hidden and the content underneath\\nthe sheet can be interacted with. This value is exclusive\\nmeaning the backdrop will become active after the value\\nspecified.\"\n                },\n                \"attribute\": \"backdrop-breakpoint\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"handle\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The horizontal line that displays at the top of a sheet modal. It is `true` by default when\\nsetting the `breakpoints` and `initialBreakpoint` properties.\"\n                },\n                \"attribute\": \"handle\",\n                \"reflect\": false\n            },\n            \"handleBehavior\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ModalHandleBehavior\",\n                    \"resolved\": \"\\\"cycle\\\" | \\\"none\\\" | undefined\",\n                    \"references\": {\n                        \"ModalHandleBehavior\": {\n                            \"location\": \"import\",\n                            \"path\": \"./modal-interface\",\n                            \"id\": \"src/components/modal/modal-interface.ts::ModalHandleBehavior\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The interaction behavior for the sheet modal when the handle is pressed.\\n\\nDefaults to `\\\"none\\\"`, which  means the modal will not change size or position when the handle is pressed.\\nSet to `\\\"cycle\\\"` to let the modal cycle between available breakpoints when pressed.\\n\\nHandle behavior is unavailable when the `handle` property is set to `false` or\\nwhen the `breakpoints` property is not set (using a fullscreen or card modal).\"\n                },\n                \"attribute\": \"handle-behavior\",\n                \"reflect\": false,\n                \"defaultValue\": \"'none'\"\n            },\n            \"component\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ComponentRef\",\n                    \"resolved\": \"Function | HTMLElement | null | string | undefined\",\n                    \"references\": {\n                        \"ComponentRef\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::ComponentRef\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"The component to display inside of the modal.\"\n                },\n                \"attribute\": \"component\",\n                \"reflect\": false\n            },\n            \"componentProps\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"ComponentProps\",\n                    \"resolved\": \"undefined | { [key: string]: any; }\",\n                    \"references\": {\n                        \"ComponentProps\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::ComponentProps\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"The data to pass to the modal component.\"\n                }\n            },\n            \"cssClass\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string | string[]\",\n                    \"resolved\": \"string | string[] | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Additional classes to apply for custom CSS. If multiple classes are\\nprovided they should be separated by spaces.\"\n                },\n                \"attribute\": \"css-class\",\n                \"reflect\": false\n            },\n            \"backdropDismiss\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the modal will be dismissed when the backdrop is clicked.\"\n                },\n                \"attribute\": \"backdrop-dismiss\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"showBackdrop\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, a backdrop will be displayed behind the modal.\\nThis property controls whether or not the backdrop\\ndarkens the screen when the modal is presented.\\nIt does not control whether or not the backdrop\\nis active or present in the DOM.\"\n                },\n                \"attribute\": \"show-backdrop\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"animated\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the modal will animate.\"\n                },\n                \"attribute\": \"animated\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"presentingElement\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"HTMLElement\",\n                    \"resolved\": \"HTMLElement | undefined\",\n                    \"references\": {\n                        \"HTMLElement\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::HTMLElement\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The element that presented the modal. This is used for card presentation effects\\nand for stacking multiple modals on top of each other. Only applies in iOS mode.\"\n                }\n            },\n            \"htmlAttributes\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"{ [key: string]: any }\",\n                    \"resolved\": \"undefined | { [key: string]: any; }\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Additional attributes to pass to the modal.\"\n                }\n            },\n            \"isOpen\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the modal will open. If `false`, the modal will close.\\nUse this if you need finer grained control over presentation, otherwise\\njust use the modalController or the `trigger` property.\\nNote: `isOpen` will not automatically be set back to `false` when\\nthe modal dismisses. You will need to do that in your code.\"\n                },\n                \"attribute\": \"is-open\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"trigger\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string | undefined\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"An ID corresponding to the trigger element that\\ncauses the modal to open when clicked.\"\n                },\n                \"attribute\": \"trigger\",\n                \"reflect\": false\n            },\n            \"keepContentsMounted\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the component passed into `ion-modal` will\\nautomatically be mounted when the modal is created. The\\ncomponent will remain mounted even when the modal is dismissed.\\nHowever, the component will be destroyed when the modal is\\ndestroyed. This property is not reactive and should only be\\nused when initially creating a modal.\\n\\nNote: This feature only applies to inline modals in JavaScript\\nframeworks such as Angular, React, and Vue.\"\n                },\n                \"attribute\": \"keep-contents-mounted\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"canDismiss\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean | ((data?: any, role?: string) => Promise<boolean>)\",\n                    \"resolved\": \"((data?: any, role?: string | undefined) => Promise<boolean>) | boolean\",\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Determines whether or not a modal can dismiss\\nwhen calling the `dismiss` method.\\n\\nIf the value is `true` or the value's function returns `true`, the modal will close when trying to dismiss.\\nIf the value is `false` or the value's function returns `false`, the modal will not close when trying to dismiss.\\n\\nSee https://ionicframework.com/docs/troubleshooting/runtime#accessing-this\\nif you need to access `this` from within the callback.\"\n                },\n                \"attribute\": \"can-dismiss\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"presented\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"didPresent\",\n                \"name\": \"ionModalDidPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the modal has presented.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willPresent\",\n                \"name\": \"ionModalWillPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the modal has presented.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willDismiss\",\n                \"name\": \"ionModalWillDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the modal has dismissed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didDismiss\",\n                \"name\": \"ionModalDidDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the modal has dismissed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionBreakpointDidChange\",\n                \"name\": \"ionBreakpointDidChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the modal breakpoint has changed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"ModalBreakpointChangeEventDetail\",\n                    \"resolved\": \"ModalBreakpointChangeEventDetail\",\n                    \"references\": {\n                        \"ModalBreakpointChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./modal-interface\",\n                            \"id\": \"src/components/modal/modal-interface.ts::ModalBreakpointChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didPresentShorthand\",\n                \"name\": \"didPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the modal has presented.\\nShorthand for ionModalDidPresent.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willPresentShorthand\",\n                \"name\": \"willPresent\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the modal has presented.\\nShorthand for ionModalWillPresent.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"willDismissShorthand\",\n                \"name\": \"willDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted before the modal has dismissed.\\nShorthand for ionModalWillDismiss.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"didDismissShorthand\",\n                \"name\": \"didDismiss\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted after the modal has dismissed.\\nShorthand for ionModalDidDismiss.\"\n                },\n                \"complexType\": {\n                    \"original\": \"OverlayEventDetail\",\n                    \"resolved\": \"OverlayEventDetail<any>\",\n                    \"references\": {\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionMount\",\n                \"name\": \"ionMount\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted before the modal has presented, but after the component\\nhas been mounted in the DOM.\\nThis event exists so iOS can run the entering\\ntransition properly\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"present\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<void>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"ModalPresentOptions\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::ModalPresentOptions\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Present the modal overlay after it has been created.\",\n                    \"tags\": []\n                }\n            },\n            \"dismiss\": {\n                \"complexType\": {\n                    \"signature\": \"(data?: any, role?: string) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"data\",\n                            \"type\": \"any\",\n                            \"docs\": \"Any data to emit in the dismiss events.\"\n                        }, {\n                            \"name\": \"role\",\n                            \"type\": \"string | undefined\",\n                            \"docs\": \"The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\\n\\nThis is a no-op if the overlay has not been presented yet. If you want\\nto remove an overlay from the DOM that was never presented, use the\\n[remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"ModalDismissOptions\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::ModalDismissOptions\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Dismiss the modal overlay after it has been presented.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"data Any data to emit in the dismiss events.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\\n\\nThis is a no-op if the overlay has not been presented yet. If you want\\nto remove an overlay from the DOM that was never presented, use the\\n[remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.\"\n                        }]\n                }\n            },\n            \"onDidDismiss\": {\n                \"complexType\": {\n                    \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        },\n                        \"T\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::T\"\n                        }\n                    },\n                    \"return\": \"Promise<OverlayEventDetail<T>>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns a promise that resolves when the modal did dismiss.\",\n                    \"tags\": []\n                }\n            },\n            \"onWillDismiss\": {\n                \"complexType\": {\n                    \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"OverlayEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../utils/overlays-interface\",\n                            \"id\": \"src/utils/overlays-interface.ts::OverlayEventDetail\"\n                        },\n                        \"T\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::T\"\n                        }\n                    },\n                    \"return\": \"Promise<OverlayEventDetail<T>>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns a promise that resolves when the modal will dismiss.\",\n                    \"tags\": []\n                }\n            },\n            \"setCurrentBreakpoint\": {\n                \"complexType\": {\n                    \"signature\": \"(breakpoint: number) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"breakpoint\",\n                            \"type\": \"number\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Move a sheet style modal to a specific breakpoint. The breakpoint value must\\nbe a value defined in your `breakpoints` array.\",\n                    \"tags\": []\n                }\n            },\n            \"getCurrentBreakpoint\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<number | undefined>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<number | undefined>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns the current breakpoint of a sheet style modal\",\n                    \"tags\": []\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"isOpen\",\n                \"methodName\": \"onIsOpenChange\"\n            }, {\n                \"propName\": \"trigger\",\n                \"methodName\": \"triggerChanged\"\n            }];\n    }\n}\nconst LIFECYCLE_MAP = {\n    ionModalDidPresent: 'ionViewDidEnter',\n    ionModalWillPresent: 'ionViewWillEnter',\n    ionModalWillDismiss: 'ionViewWillLeave',\n    ionModalDidDismiss: 'ionViewDidLeave',\n};\n"],"mappings":"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"}