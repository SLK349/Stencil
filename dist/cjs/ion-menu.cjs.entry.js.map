{"file":"ion-menu.entry.cjs.js","mappings":"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","names":["GESTURE_CONTROLLER","getPresentedOverlay","isEnd","config","menuController","inheritAriaAttributes","focusFirstDescendant","focusLastDescendant","getIonMode","assert","getTimeGivenProgression","clamp","h","Host","shouldUseCloseWatcher","hostContext"],"sources":["node_modules/@ionic/core/dist/collection/components/menu/menu.ios.css?tag=ion-menu&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/menu/menu.md.css?tag=ion-menu&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/menu/menu.js"],"sourcesContent":["/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the menu\n   *\n   * @prop --min-width: Minimum width of the menu\n   * @prop --width: Width of the menu\n   * @prop --max-width: Maximum width of the menu\n   *\n   * @prop --min-height: Minimum height of the menu\n   * @prop --height: Height of the menu\n   * @prop --max-height: Maximum height of the menu\n   */\n  --width: 304px;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --background: var(--ion-background-color, #fff);\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: none;\n  position: absolute;\n  contain: strict;\n}\n\n:host(.show-menu) {\n  display: block;\n}\n\n.menu-inner {\n  transform: translateX(-9999px);\n  display: flex;\n  position: absolute;\n  flex-direction: column;\n  justify-content: space-between;\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  background: var(--background);\n  contain: strict;\n}\n\n:host(.menu-side-start) .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * LTR:\n    * The left side of the menu touches the screen edge. The safe area padding has\n    * already been set in the core styles, so there's no need to set it again.\n    * The right side of the menu is not touching the screen edge. Padding is not\n    * applied to the right side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-right: 0px;\n  top: 0;\n  bottom: 0;\n}\n:host(.menu-side-start) .menu-inner {\n  inset-inline-start: 0;\n  inset-inline-end: auto;\n}\n\n:host-context([dir=rtl]):host(.menu-side-start) .menu-inner, :host-context([dir=rtl]).menu-side-start .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * RTL:\n    * The right side of the menu touches the screen edge.\n    * The right side needs to revert back to the default value that was set in the core styles, so we unset it here.\n    * This would keep the variable consistent with the core styles.\n    * Additionally, it would continue to allow users to override the variable if they choose to.\n    * The left side of the menu is not touching the screen edge. Padding is not\n    * applied to the left side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-right: unset;\n  --ion-safe-area-left: 0px;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.menu-side-start:dir(rtl)) .menu-inner {\n    /**\n      * Menu does not cover the whole screen so we need to set the safe area for the\n      * side that touches the screen edge only. Since safe area is not logical, it\n      * needs to be applied to the correct side depending on the language direction.\n      * Otherwise, the content will have less space on both sides.\n      *\n      * RTL:\n      * The right side of the menu touches the screen edge.\n      * The right side needs to revert back to the default value that was set in the core styles, so we unset it here.\n      * This would keep the variable consistent with the core styles.\n      * Additionally, it would continue to allow users to override the variable if they choose to.\n      * The left side of the menu is not touching the screen edge. Padding is not\n      * applied to the left side of the menu. A value of 0 is set.\n      */\n    --ion-safe-area-right: unset;\n    --ion-safe-area-left: 0px;\n  }\n}\n\n:host(.menu-side-end) .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * LTR:\n    * The right side of the menu touches the screen edge. The safe area padding has\n    * already been set in the core styles, so there's no need to set it again.\n    * The left side of the menu is not touching the screen edge. Padding is not\n    * applied to the left side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-left: 0px;\n  top: 0;\n  bottom: 0;\n}\n:host(.menu-side-end) .menu-inner {\n  inset-inline-start: auto;\n  inset-inline-end: 0;\n}\n\n:host-context([dir=rtl]):host(.menu-side-end) .menu-inner, :host-context([dir=rtl]).menu-side-end .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * RTL:\n    * The left side of the menu touches the screen edge.\n    * The left side needs to revert back to the default value that was set in the core styles, so we unset it here.\n    * This would keep the variable consistent with the core styles.\n    * Additionally, it would continue to allow users to override the variable if they choose to.\n    * The right side of the menu is not touching the screen edge. Padding is not\n    * applied to the right side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-left: unset;\n  --ion-safe-area-right: 0px;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.menu-side-end:dir(rtl)) .menu-inner {\n    /**\n      * Menu does not cover the whole screen so we need to set the safe area for the\n      * side that touches the screen edge only. Since safe area is not logical, it\n      * needs to be applied to the correct side depending on the language direction.\n      * Otherwise, the content will have less space on both sides.\n      *\n      * RTL:\n      * The left side of the menu touches the screen edge.\n      * The left side needs to revert back to the default value that was set in the core styles, so we unset it here.\n      * This would keep the variable consistent with the core styles.\n      * Additionally, it would continue to allow users to override the variable if they choose to.\n      * The right side of the menu is not touching the screen edge. Padding is not\n      * applied to the right side of the menu. A value of 0 is set.\n      */\n    --ion-safe-area-left: unset;\n    --ion-safe-area-right: 0px;\n  }\n}\n\nion-backdrop {\n  display: none;\n  opacity: 0.01;\n  z-index: -1;\n}\n\n@media (max-width: 340px) {\n  .menu-inner {\n    --width: 264px;\n  }\n}\n:host(.menu-type-reveal) {\n  z-index: 0;\n}\n\n:host(.menu-type-reveal.show-menu) .menu-inner {\n  transform: translate3d(0,  0,  0);\n}\n\n:host(.menu-type-overlay) {\n  z-index: 1000;\n}\n\n:host(.menu-type-overlay) .show-backdrop {\n  display: block;\n  cursor: pointer;\n}\n\n/**\n * The split pane styles for menu are defined\n * in the menu stylesheets instead in the split pane\n * stylesheets with ::slotted to allow for menus\n * to be wrapped in custom components.\n * If we used ::slotted to target the menu\n * then menus wrapped in components would never\n * receive these styles because they are not\n * children of the split pane.\n */\n/**\n * Do not pass CSS Variables down on larger\n * screens as we want them to affect the outer\n * `ion-menu` rather than the inner content\n */\n:host(.menu-pane-visible) {\n  flex: 0 1 auto;\n  width: var(--side-width, var(--width));\n  min-width: var(--side-min-width, var(--min-width));\n  max-width: var(--side-max-width, var(--max-width));\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: relative;\n  box-shadow: none;\n  z-index: 0;\n}\n\n:host(.menu-pane-visible.split-pane-side.menu-enabled) {\n  display: flex;\n  flex-shrink: 0;\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  order: -1;\n}\n\n:host(.menu-pane-visible.split-pane-side[side=end]) {\n  order: 1;\n}\n\n:host(.menu-pane-visible) .menu-inner {\n  left: 0;\n  right: 0;\n  width: auto;\n  transform: none;\n  box-shadow: none;\n}\n\n:host(.menu-pane-visible) ion-backdrop {\n  /* stylelint-disable-next-line declaration-no-important */\n  display: hidden !important;\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  -webkit-border-start: 0;\n  border-inline-start: 0;\n  -webkit-border-end: var(--border);\n  border-inline-end: var(--border);\n  border-top: 0;\n  border-bottom: 0;\n  min-width: var(--side-min-width);\n  max-width: var(--side-max-width);\n}\n\n:host(.menu-pane-visible.split-pane-side[side=end]) {\n  -webkit-border-start: var(--border);\n  border-inline-start: var(--border);\n  -webkit-border-end: 0;\n  border-inline-end: 0;\n  border-top: 0;\n  border-bottom: 0;\n  min-width: var(--side-min-width);\n  max-width: var(--side-max-width);\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host(.menu-type-push) {\n  z-index: 1000;\n}\n\n:host(.menu-type-push) .show-backdrop {\n  display: block;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the menu\n   *\n   * @prop --min-width: Minimum width of the menu\n   * @prop --width: Width of the menu\n   * @prop --max-width: Maximum width of the menu\n   *\n   * @prop --min-height: Minimum height of the menu\n   * @prop --height: Height of the menu\n   * @prop --max-height: Maximum height of the menu\n   */\n  --width: 304px;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --background: var(--ion-background-color, #fff);\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: none;\n  position: absolute;\n  contain: strict;\n}\n\n:host(.show-menu) {\n  display: block;\n}\n\n.menu-inner {\n  transform: translateX(-9999px);\n  display: flex;\n  position: absolute;\n  flex-direction: column;\n  justify-content: space-between;\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  background: var(--background);\n  contain: strict;\n}\n\n:host(.menu-side-start) .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * LTR:\n    * The left side of the menu touches the screen edge. The safe area padding has\n    * already been set in the core styles, so there's no need to set it again.\n    * The right side of the menu is not touching the screen edge. Padding is not\n    * applied to the right side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-right: 0px;\n  top: 0;\n  bottom: 0;\n}\n:host(.menu-side-start) .menu-inner {\n  inset-inline-start: 0;\n  inset-inline-end: auto;\n}\n\n:host-context([dir=rtl]):host(.menu-side-start) .menu-inner, :host-context([dir=rtl]).menu-side-start .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * RTL:\n    * The right side of the menu touches the screen edge.\n    * The right side needs to revert back to the default value that was set in the core styles, so we unset it here.\n    * This would keep the variable consistent with the core styles.\n    * Additionally, it would continue to allow users to override the variable if they choose to.\n    * The left side of the menu is not touching the screen edge. Padding is not\n    * applied to the left side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-right: unset;\n  --ion-safe-area-left: 0px;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.menu-side-start:dir(rtl)) .menu-inner {\n    /**\n      * Menu does not cover the whole screen so we need to set the safe area for the\n      * side that touches the screen edge only. Since safe area is not logical, it\n      * needs to be applied to the correct side depending on the language direction.\n      * Otherwise, the content will have less space on both sides.\n      *\n      * RTL:\n      * The right side of the menu touches the screen edge.\n      * The right side needs to revert back to the default value that was set in the core styles, so we unset it here.\n      * This would keep the variable consistent with the core styles.\n      * Additionally, it would continue to allow users to override the variable if they choose to.\n      * The left side of the menu is not touching the screen edge. Padding is not\n      * applied to the left side of the menu. A value of 0 is set.\n      */\n    --ion-safe-area-right: unset;\n    --ion-safe-area-left: 0px;\n  }\n}\n\n:host(.menu-side-end) .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * LTR:\n    * The right side of the menu touches the screen edge. The safe area padding has\n    * already been set in the core styles, so there's no need to set it again.\n    * The left side of the menu is not touching the screen edge. Padding is not\n    * applied to the left side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-left: 0px;\n  top: 0;\n  bottom: 0;\n}\n:host(.menu-side-end) .menu-inner {\n  inset-inline-start: auto;\n  inset-inline-end: 0;\n}\n\n:host-context([dir=rtl]):host(.menu-side-end) .menu-inner, :host-context([dir=rtl]).menu-side-end .menu-inner {\n  /**\n    * Menu does not cover the whole screen so we need to set the safe area for the\n    * side that touches the screen edge only. Since safe area is not logical, it\n    * needs to be applied to the correct side depending on the language direction.\n    * Otherwise, the content will have less space on both sides.\n    *\n    * RTL:\n    * The left side of the menu touches the screen edge.\n    * The left side needs to revert back to the default value that was set in the core styles, so we unset it here.\n    * This would keep the variable consistent with the core styles.\n    * Additionally, it would continue to allow users to override the variable if they choose to.\n    * The right side of the menu is not touching the screen edge. Padding is not\n    * applied to the right side of the menu. A value of 0 is set.\n    */\n  --ion-safe-area-left: unset;\n  --ion-safe-area-right: 0px;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.menu-side-end:dir(rtl)) .menu-inner {\n    /**\n      * Menu does not cover the whole screen so we need to set the safe area for the\n      * side that touches the screen edge only. Since safe area is not logical, it\n      * needs to be applied to the correct side depending on the language direction.\n      * Otherwise, the content will have less space on both sides.\n      *\n      * RTL:\n      * The left side of the menu touches the screen edge.\n      * The left side needs to revert back to the default value that was set in the core styles, so we unset it here.\n      * This would keep the variable consistent with the core styles.\n      * Additionally, it would continue to allow users to override the variable if they choose to.\n      * The right side of the menu is not touching the screen edge. Padding is not\n      * applied to the right side of the menu. A value of 0 is set.\n      */\n    --ion-safe-area-left: unset;\n    --ion-safe-area-right: 0px;\n  }\n}\n\nion-backdrop {\n  display: none;\n  opacity: 0.01;\n  z-index: -1;\n}\n\n@media (max-width: 340px) {\n  .menu-inner {\n    --width: 264px;\n  }\n}\n:host(.menu-type-reveal) {\n  z-index: 0;\n}\n\n:host(.menu-type-reveal.show-menu) .menu-inner {\n  transform: translate3d(0,  0,  0);\n}\n\n:host(.menu-type-overlay) {\n  z-index: 1000;\n}\n\n:host(.menu-type-overlay) .show-backdrop {\n  display: block;\n  cursor: pointer;\n}\n\n/**\n * The split pane styles for menu are defined\n * in the menu stylesheets instead in the split pane\n * stylesheets with ::slotted to allow for menus\n * to be wrapped in custom components.\n * If we used ::slotted to target the menu\n * then menus wrapped in components would never\n * receive these styles because they are not\n * children of the split pane.\n */\n/**\n * Do not pass CSS Variables down on larger\n * screens as we want them to affect the outer\n * `ion-menu` rather than the inner content\n */\n:host(.menu-pane-visible) {\n  flex: 0 1 auto;\n  width: var(--side-width, var(--width));\n  min-width: var(--side-min-width, var(--min-width));\n  max-width: var(--side-max-width, var(--max-width));\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: relative;\n  box-shadow: none;\n  z-index: 0;\n}\n\n:host(.menu-pane-visible.split-pane-side.menu-enabled) {\n  display: flex;\n  flex-shrink: 0;\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  order: -1;\n}\n\n:host(.menu-pane-visible.split-pane-side[side=end]) {\n  order: 1;\n}\n\n:host(.menu-pane-visible) .menu-inner {\n  left: 0;\n  right: 0;\n  width: auto;\n  transform: none;\n  box-shadow: none;\n}\n\n:host(.menu-pane-visible) ion-backdrop {\n  /* stylelint-disable-next-line declaration-no-important */\n  display: hidden !important;\n}\n\n:host(.menu-pane-visible.split-pane-side) {\n  -webkit-border-start: 0;\n  border-inline-start: 0;\n  -webkit-border-end: var(--border);\n  border-inline-end: var(--border);\n  border-top: 0;\n  border-bottom: 0;\n  min-width: var(--side-min-width);\n  max-width: var(--side-max-width);\n}\n\n:host(.menu-pane-visible.split-pane-side[side=end]) {\n  -webkit-border-start: var(--border);\n  border-inline-start: var(--border);\n  -webkit-border-end: 0;\n  border-inline-end: 0;\n  border-top: 0;\n  border-bottom: 0;\n  min-width: var(--side-min-width);\n  max-width: var(--side-max-width);\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host(.menu-type-overlay) .menu-inner {\n  box-shadow: 4px 0px 16px rgba(0, 0, 0, 0.18);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Build, Host, h } from \"@stencil/core\";\nimport { getTimeGivenProgression } from \"../../utils/animation/cubic-bezier\";\nimport { focusFirstDescendant, focusLastDescendant } from \"../../utils/focus-trap\";\nimport { GESTURE_CONTROLLER } from \"../../utils/gesture/index\";\nimport { shouldUseCloseWatcher } from \"../../utils/hardware-back-button\";\nimport { inheritAriaAttributes, assert, clamp, isEndSide as isEnd } from \"../../utils/helpers\";\nimport { menuController } from \"../../utils/menu-controller/index\";\nimport { getPresentedOverlay } from \"../../utils/overlays\";\nimport { hostContext } from \"../../utils/theme\";\nimport { config } from \"../../global/config\";\nimport { getIonMode } from \"../../global/ionic-global\";\nconst iosEasing = 'cubic-bezier(0.32,0.72,0,1)';\nconst mdEasing = 'cubic-bezier(0.0,0.0,0.2,1)';\nconst iosEasingReverse = 'cubic-bezier(1, 0, 0.68, 0.28)';\nconst mdEasingReverse = 'cubic-bezier(0.4, 0, 0.6, 1)';\n/**\n * @part container - The container for the menu content.\n * @part backdrop - The backdrop that appears over the main content when the menu is open.\n */\nexport class Menu {\n    constructor() {\n        this.lastOnEnd = 0;\n        this.blocker = GESTURE_CONTROLLER.createBlocker({ disableScroll: true });\n        this.didLoad = false;\n        /**\n         * Flag used to determine if an open/close\n         * operation was cancelled. For example, if\n         * an app calls \"menu.open\" then disables the menu\n         * part way through the animation, then this would\n         * be considered a cancelled operation.\n         */\n        this.operationCancelled = false;\n        this.isAnimating = false;\n        this._isOpen = false;\n        this.inheritedAttributes = {};\n        this.handleFocus = (ev) => {\n            /**\n             * Overlays have their own focus trapping listener\n             * so we do not want the two listeners to conflict\n             * with each other. If the top-most overlay that is\n             * open does not contain this ion-menu, then ion-menu's\n             * focus trapping should not run.\n             */\n            const lastOverlay = getPresentedOverlay(document);\n            if (lastOverlay && !lastOverlay.contains(this.el)) {\n                return;\n            }\n            this.trapKeyboardFocus(ev, document);\n        };\n        this.isPaneVisible = false;\n        this.isEndSide = false;\n        this.contentId = undefined;\n        this.menuId = undefined;\n        this.type = undefined;\n        this.disabled = false;\n        this.side = 'start';\n        this.swipeGesture = true;\n        this.maxEdgeStart = 50;\n    }\n    typeChanged(type, oldType) {\n        const contentEl = this.contentEl;\n        if (contentEl) {\n            if (oldType !== undefined) {\n                contentEl.classList.remove(`menu-content-${oldType}`);\n            }\n            contentEl.classList.add(`menu-content-${type}`);\n            contentEl.removeAttribute('style');\n        }\n        if (this.menuInnerEl) {\n            // Remove effects of previous animations\n            this.menuInnerEl.removeAttribute('style');\n        }\n        this.animation = undefined;\n    }\n    disabledChanged() {\n        this.updateState();\n        this.ionMenuChange.emit({\n            disabled: this.disabled,\n            open: this._isOpen,\n        });\n    }\n    sideChanged() {\n        this.isEndSide = isEnd(this.side);\n        /**\n         * Menu direction animation is calculated based on the document direction.\n         * If the document direction changes, we need to create a new animation.\n         */\n        this.animation = undefined;\n    }\n    swipeGestureChanged() {\n        this.updateState();\n    }\n    async connectedCallback() {\n        // TODO: connectedCallback is fired in CE build\n        // before WC is defined. This needs to be fixed in Stencil.\n        if (typeof customElements !== 'undefined' && customElements != null) {\n            await customElements.whenDefined('ion-menu');\n        }\n        if (this.type === undefined) {\n            this.type = config.get('menuType', 'overlay');\n        }\n        if (!Build.isBrowser) {\n            return;\n        }\n        const content = this.contentId !== undefined ? document.getElementById(this.contentId) : null;\n        if (content === null) {\n            console.error('Menu: must have a \"content\" element to listen for drag events on.');\n            return;\n        }\n        if (this.el.contains(content)) {\n            console.error(`Menu: \"contentId\" should refer to the main view's ion-content, not the ion-content inside of the ion-menu.`);\n        }\n        this.contentEl = content;\n        // add menu's content classes\n        content.classList.add('menu-content');\n        this.typeChanged(this.type, undefined);\n        this.sideChanged();\n        // register this menu with the app's menu controller\n        menuController._register(this);\n        this.menuChanged();\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n            el: document,\n            gestureName: 'menu-swipe',\n            gesturePriority: 30,\n            threshold: 10,\n            blurOnStart: true,\n            canStart: (ev) => this.canStart(ev),\n            onWillStart: () => this.onWillStart(),\n            onStart: () => this.onStart(),\n            onMove: (ev) => this.onMove(ev),\n            onEnd: (ev) => this.onEnd(ev),\n        });\n        this.updateState();\n    }\n    componentWillLoad() {\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\n    }\n    async componentDidLoad() {\n        this.didLoad = true;\n        /**\n         * A menu inside of a split pane is assumed\n         * to be a side pane.\n         *\n         * When the menu is loaded it needs to\n         * see if it should be considered visible inside\n         * of the split pane. If the split pane is\n         * hidden then the menu should be too.\n         */\n        const splitPane = this.el.closest('ion-split-pane');\n        if (splitPane !== null) {\n            this.isPaneVisible = await splitPane.isVisible();\n        }\n        this.menuChanged();\n        this.updateState();\n    }\n    menuChanged() {\n        /**\n         * Inform dependent components such as ion-menu-button\n         * that the menu is ready. Note that we only want to do this\n         * once the menu has been rendered which is why we check for didLoad.\n         */\n        if (this.didLoad) {\n            this.ionMenuChange.emit({ disabled: this.disabled, open: this._isOpen });\n        }\n    }\n    async disconnectedCallback() {\n        /**\n         * The menu should be closed when it is\n         * unmounted from the DOM.\n         * This is an async call, so we need to wait for\n         * this to finish otherwise contentEl\n         * will not have MENU_CONTENT_OPEN removed.\n         */\n        await this.close(false);\n        this.blocker.destroy();\n        menuController._unregister(this);\n        if (this.animation) {\n            this.animation.destroy();\n        }\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n        this.animation = undefined;\n        this.contentEl = undefined;\n    }\n    onSplitPaneChanged(ev) {\n        const closestSplitPane = this.el.closest('ion-split-pane');\n        if (closestSplitPane !== null && closestSplitPane === ev.target) {\n            this.isPaneVisible = ev.detail.visible;\n            this.updateState();\n        }\n    }\n    onBackdropClick(ev) {\n        // TODO(FW-2832): type (CustomEvent triggers errors which should be sorted)\n        if (this._isOpen && this.lastOnEnd < ev.timeStamp - 100) {\n            const shouldClose = ev.composedPath ? !ev.composedPath().includes(this.menuInnerEl) : false;\n            if (shouldClose) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.close();\n            }\n        }\n    }\n    onKeydown(ev) {\n        if (ev.key === 'Escape') {\n            this.close();\n        }\n    }\n    /**\n     * Returns `true` is the menu is open.\n     */\n    isOpen() {\n        return Promise.resolve(this._isOpen);\n    }\n    /**\n     * Returns `true` is the menu is active.\n     *\n     * A menu is active when it can be opened or closed, meaning it's enabled\n     * and it's not part of a `ion-split-pane`.\n     */\n    isActive() {\n        return Promise.resolve(this._isActive());\n    }\n    /**\n     * Opens the menu. If the menu is already open or it can't be opened,\n     * it returns `false`.\n     */\n    open(animated = true) {\n        return this.setOpen(true, animated);\n    }\n    /**\n     * Closes the menu. If the menu is already closed or it can't be closed,\n     * it returns `false`.\n     */\n    close(animated = true) {\n        return this.setOpen(false, animated);\n    }\n    /**\n     * Toggles the menu. If the menu is already open, it will try to close, otherwise it will try to open it.\n     * If the operation can't be completed successfully, it returns `false`.\n     */\n    toggle(animated = true) {\n        return this.setOpen(!this._isOpen, animated);\n    }\n    /**\n     * Opens or closes the button.\n     * If the operation can't be completed successfully, it returns `false`.\n     */\n    setOpen(shouldOpen, animated = true) {\n        return menuController._setOpen(this, shouldOpen, animated);\n    }\n    trapKeyboardFocus(ev, doc) {\n        const target = ev.target;\n        if (!target) {\n            return;\n        }\n        /**\n         * If the target is inside the menu contents, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (this.el.contains(target)) {\n            this.lastFocus = target;\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus go out of the menu.\n             * Wrap the focus to either the first or last element.\n             */\n            const { el } = this;\n            /**\n             * Once we call `focusFirstDescendant`, another focus event\n             * will fire, which will cause `lastFocus` to be updated\n             * before we can run the code after that. We cache the value\n             * here to avoid that.\n             */\n            focusFirstDescendant(el);\n            /**\n             * If the cached last focused element is the same as the now-\n             * active element, that means the user was on the first element\n             * already and pressed Shift + Tab, so we need to wrap to the\n             * last descendant.\n             */\n            if (this.lastFocus === doc.activeElement) {\n                focusLastDescendant(el);\n            }\n        }\n    }\n    async _setOpen(shouldOpen, animated = true) {\n        // If the menu is disabled or it is currently being animated, let's do nothing\n        if (!this._isActive() || this.isAnimating || shouldOpen === this._isOpen) {\n            return false;\n        }\n        this.beforeAnimation(shouldOpen);\n        await this.loadAnimation();\n        await this.startAnimation(shouldOpen, animated);\n        /**\n         * If the animation was cancelled then\n         * return false because the operation\n         * did not succeed.\n         */\n        if (this.operationCancelled) {\n            this.operationCancelled = false;\n            return false;\n        }\n        this.afterAnimation(shouldOpen);\n        return true;\n    }\n    async loadAnimation() {\n        // Menu swipe animation takes the menu's inner width as parameter,\n        // If `offsetWidth` changes, we need to create a new animation.\n        const width = this.menuInnerEl.offsetWidth;\n        /**\n         * Menu direction animation is calculated based on the document direction.\n         * If the document direction changes, we need to create a new animation.\n         */\n        const isEndSide = isEnd(this.side);\n        if (width === this.width && this.animation !== undefined && isEndSide === this.isEndSide) {\n            return;\n        }\n        this.width = width;\n        this.isEndSide = isEndSide;\n        // Destroy existing animation\n        if (this.animation) {\n            this.animation.destroy();\n            this.animation = undefined;\n        }\n        // Create new animation\n        const animation = (this.animation = await menuController._createAnimation(this.type, this));\n        if (!config.getBoolean('animated', true)) {\n            animation.duration(0);\n        }\n        animation.fill('both');\n    }\n    async startAnimation(shouldOpen, animated) {\n        const isReversed = !shouldOpen;\n        const mode = getIonMode(this);\n        const easing = mode === 'ios' ? iosEasing : mdEasing;\n        const easingReverse = mode === 'ios' ? iosEasingReverse : mdEasingReverse;\n        const ani = this.animation\n            .direction(isReversed ? 'reverse' : 'normal')\n            .easing(isReversed ? easingReverse : easing);\n        if (animated) {\n            await ani.play();\n        }\n        else {\n            ani.play({ sync: true });\n        }\n        /**\n         * We run this after the play invocation\n         * instead of using ani.onFinish so that\n         * multiple onFinish callbacks do not get\n         * run if an animation is played, stopped,\n         * and then played again.\n         */\n        if (ani.getDirection() === 'reverse') {\n            ani.direction('normal');\n        }\n    }\n    _isActive() {\n        return !this.disabled && !this.isPaneVisible;\n    }\n    canSwipe() {\n        return this.swipeGesture && !this.isAnimating && this._isActive();\n    }\n    canStart(detail) {\n        // Do not allow swipe gesture if a modal is open\n        const isModalPresented = !!document.querySelector('ion-modal.show-modal');\n        if (isModalPresented || !this.canSwipe()) {\n            return false;\n        }\n        if (this._isOpen) {\n            return true;\n        }\n        else if (menuController._getOpenSync()) {\n            return false;\n        }\n        return checkEdgeSide(window, detail.currentX, this.isEndSide, this.maxEdgeStart);\n    }\n    onWillStart() {\n        this.beforeAnimation(!this._isOpen);\n        return this.loadAnimation();\n    }\n    onStart() {\n        if (!this.isAnimating || !this.animation) {\n            assert(false, 'isAnimating has to be true');\n            return;\n        }\n        // the cloned animation should not use an easing curve during seek\n        this.animation.progressStart(true, this._isOpen ? 1 : 0);\n    }\n    onMove(detail) {\n        if (!this.isAnimating || !this.animation) {\n            assert(false, 'isAnimating has to be true');\n            return;\n        }\n        const delta = computeDelta(detail.deltaX, this._isOpen, this.isEndSide);\n        const stepValue = delta / this.width;\n        this.animation.progressStep(this._isOpen ? 1 - stepValue : stepValue);\n    }\n    onEnd(detail) {\n        if (!this.isAnimating || !this.animation) {\n            assert(false, 'isAnimating has to be true');\n            return;\n        }\n        const isOpen = this._isOpen;\n        const isEndSide = this.isEndSide;\n        const delta = computeDelta(detail.deltaX, isOpen, isEndSide);\n        const width = this.width;\n        const stepValue = delta / width;\n        const velocity = detail.velocityX;\n        const z = width / 2.0;\n        const shouldCompleteRight = velocity >= 0 && (velocity > 0.2 || detail.deltaX > z);\n        const shouldCompleteLeft = velocity <= 0 && (velocity < -0.2 || detail.deltaX < -z);\n        const shouldComplete = isOpen\n            ? isEndSide\n                ? shouldCompleteRight\n                : shouldCompleteLeft\n            : isEndSide\n                ? shouldCompleteLeft\n                : shouldCompleteRight;\n        let shouldOpen = !isOpen && shouldComplete;\n        if (isOpen && !shouldComplete) {\n            shouldOpen = true;\n        }\n        this.lastOnEnd = detail.currentTime;\n        // Account for rounding errors in JS\n        let newStepValue = shouldComplete ? 0.001 : -0.001;\n        /**\n         * stepValue can sometimes return a negative\n         * value, but you can't have a negative time value\n         * for the cubic bezier curve (at least with web animations)\n         */\n        const adjustedStepValue = stepValue < 0 ? 0.01 : stepValue;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        newStepValue +=\n            getTimeGivenProgression([0, 0], [0.4, 0], [0.6, 1], [1, 1], clamp(0, adjustedStepValue, 0.9999))[0] || 0;\n        const playTo = this._isOpen ? !shouldComplete : shouldComplete;\n        this.animation\n            .easing('cubic-bezier(0.4, 0.0, 0.6, 1)')\n            .onFinish(() => this.afterAnimation(shouldOpen), { oneTimeCallback: true })\n            .progressEnd(playTo ? 1 : 0, this._isOpen ? 1 - newStepValue : newStepValue, 300);\n    }\n    beforeAnimation(shouldOpen) {\n        assert(!this.isAnimating, '_before() should not be called while animating');\n        // this places the menu into the correct location before it animates in\n        // this css class doesn't actually kick off any animations\n        this.el.classList.add(SHOW_MENU);\n        /**\n         * We add a tabindex here so that focus trapping\n         * still works even if the menu does not have\n         * any focusable elements slotted inside. The\n         * focus trapping utility will fallback to focusing\n         * the menu so focus does not leave when the menu\n         * is open.\n         */\n        this.el.setAttribute('tabindex', '0');\n        if (this.backdropEl) {\n            this.backdropEl.classList.add(SHOW_BACKDROP);\n        }\n        // add css class and hide content behind menu from screen readers\n        if (this.contentEl) {\n            this.contentEl.classList.add(MENU_CONTENT_OPEN);\n            /**\n             * When the menu is open and overlaying the main\n             * content, the main content should not be announced\n             * by the screenreader as the menu is the main\n             * focus. This is useful with screenreaders that have\n             * \"read from top\" gestures that read the entire\n             * page from top to bottom when activated.\n             * This should be done before the animation starts\n             * so that users cannot accidentally scroll\n             * the content while dragging a menu open.\n             */\n            this.contentEl.setAttribute('aria-hidden', 'true');\n        }\n        this.blocker.block();\n        this.isAnimating = true;\n        if (shouldOpen) {\n            this.ionWillOpen.emit();\n        }\n        else {\n            this.ionWillClose.emit();\n        }\n    }\n    afterAnimation(isOpen) {\n        var _a;\n        // keep opening/closing the menu disabled for a touch more yet\n        // only add listeners/css if it's enabled and isOpen\n        // and only remove listeners/css if it's not open\n        // emit opened/closed events\n        this._isOpen = isOpen;\n        this.isAnimating = false;\n        if (!this._isOpen) {\n            this.blocker.unblock();\n        }\n        if (isOpen) {\n            // emit open event\n            this.ionDidOpen.emit();\n            /**\n             * Move focus to the menu to prepare focus trapping, as long as\n             * it isn't already focused. Use the host element instead of the\n             * first descendant to avoid the scroll position jumping around.\n             */\n            const focusedMenu = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('ion-menu');\n            if (focusedMenu !== this.el) {\n                this.el.focus();\n            }\n            // start focus trapping\n            document.addEventListener('focus', this.handleFocus, true);\n        }\n        else {\n            // remove css classes and unhide content from screen readers\n            this.el.classList.remove(SHOW_MENU);\n            /**\n             * Remove tabindex from the menu component\n             * so that is cannot be tabbed to.\n             */\n            this.el.removeAttribute('tabindex');\n            if (this.contentEl) {\n                this.contentEl.classList.remove(MENU_CONTENT_OPEN);\n                /**\n                 * Remove aria-hidden so screen readers\n                 * can announce the main content again\n                 * now that the menu is not the main focus.\n                 */\n                this.contentEl.removeAttribute('aria-hidden');\n            }\n            if (this.backdropEl) {\n                this.backdropEl.classList.remove(SHOW_BACKDROP);\n            }\n            if (this.animation) {\n                this.animation.stop();\n            }\n            // emit close event\n            this.ionDidClose.emit();\n            // undo focus trapping so multiple menus don't collide\n            document.removeEventListener('focus', this.handleFocus, true);\n        }\n    }\n    updateState() {\n        const isActive = this._isActive();\n        if (this.gesture) {\n            this.gesture.enable(isActive && this.swipeGesture);\n        }\n        /**\n         * If the menu is disabled but it is still open\n         * then we should close the menu immediately.\n         * Additionally, if the menu is in the process\n         * of animating {open, close} and the menu is disabled\n         * then it should still be closed immediately.\n         */\n        if (!isActive) {\n            /**\n             * It is possible to disable the menu while\n             * it is mid-animation. When this happens, we\n             * need to set the operationCancelled flag\n             * so that this._setOpen knows to return false\n             * and not run the \"afterAnimation\" callback.\n             */\n            if (this.isAnimating) {\n                this.operationCancelled = true;\n            }\n            /**\n             * If the menu is disabled then we should\n             * forcibly close the menu even if it is open.\n             */\n            this.afterAnimation(false);\n        }\n    }\n    render() {\n        const { type, disabled, el, isPaneVisible, inheritedAttributes, side } = this;\n        const mode = getIonMode(this);\n        /**\n         * If the Close Watcher is enabled then\n         * the ionBackButton listener in the menu controller\n         * will handle closing the menu when Escape is pressed.\n         */\n        return (h(Host, { key: '68ea0bdf902c1f6369db93d69cacc0f30e1df32b', onKeyDown: shouldUseCloseWatcher() ? null : this.onKeydown, role: \"navigation\", \"aria-label\": inheritedAttributes['aria-label'] || 'menu', class: {\n                [mode]: true,\n                [`menu-type-${type}`]: true,\n                'menu-enabled': !disabled,\n                [`menu-side-${side}`]: true,\n                'menu-pane-visible': isPaneVisible,\n                'split-pane-side': hostContext('ion-split-pane', el),\n            } }, h(\"div\", { key: '7f32097faa4dcf64a568c7cf4b8397bbffc9f7a4', class: \"menu-inner\", part: \"container\", ref: (el) => (this.menuInnerEl = el) }, h(\"slot\", { key: '3d4fbc9142297708aa1b31eed875afe6ea79de04' })), h(\"ion-backdrop\", { key: 'f29f4615913da302212d54a43dce94ca5bfa86a5', ref: (el) => (this.backdropEl = el), class: \"menu-backdrop\", tappable: false, stopPropagation: false, part: \"backdrop\" })));\n    }\n    static get is() { return \"ion-menu\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"menu.ios.scss\"],\n            \"md\": [\"menu.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"menu.ios.css\"],\n            \"md\": [\"menu.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"contentId\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `id` of the main content. When using\\na router this is typically `ion-router-outlet`.\\nWhen not using a router, this is typically\\nyour main view's `ion-content`. This is not the\\nid of the `ion-content` inside of your `ion-menu`.\"\n                },\n                \"attribute\": \"content-id\",\n                \"reflect\": true\n            },\n            \"menuId\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"An id for the menu.\"\n                },\n                \"attribute\": \"menu-id\",\n                \"reflect\": true\n            },\n            \"type\": {\n                \"type\": \"string\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"MenuType\",\n                    \"resolved\": \"\\\"overlay\\\" | \\\"push\\\" | \\\"reveal\\\" | undefined\",\n                    \"references\": {\n                        \"MenuType\": {\n                            \"location\": \"import\",\n                            \"path\": \"./menu-interface\",\n                            \"id\": \"src/components/menu/menu-interface.ts::MenuType\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The display type of the menu.\\nAvailable options: `\\\"overlay\\\"`, `\\\"reveal\\\"`, `\\\"push\\\"`.\"\n                },\n                \"attribute\": \"type\",\n                \"reflect\": false\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the menu is disabled.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"side\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Side\",\n                    \"resolved\": \"\\\"end\\\" | \\\"start\\\"\",\n                    \"references\": {\n                        \"Side\": {\n                            \"location\": \"import\",\n                            \"path\": \"./menu-interface\",\n                            \"id\": \"src/components/menu/menu-interface.ts::Side\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Which side of the view the menu should be placed.\"\n                },\n                \"attribute\": \"side\",\n                \"reflect\": true,\n                \"defaultValue\": \"'start'\"\n            },\n            \"swipeGesture\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, swiping the menu is enabled.\"\n                },\n                \"attribute\": \"swipe-gesture\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"maxEdgeStart\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The edge threshold for dragging the menu open.\\nIf a drag/swipe happens over this value, the menu is not triggered.\"\n                },\n                \"attribute\": \"max-edge-start\",\n                \"reflect\": false,\n                \"defaultValue\": \"50\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"isPaneVisible\": {},\n            \"isEndSide\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionWillOpen\",\n                \"name\": \"ionWillOpen\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the menu is about to be opened.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionWillClose\",\n                \"name\": \"ionWillClose\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the menu is about to be closed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionDidOpen\",\n                \"name\": \"ionDidOpen\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the menu is open.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionDidClose\",\n                \"name\": \"ionDidClose\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the menu is closed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionMenuChange\",\n                \"name\": \"ionMenuChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the menu state is changed.\"\n                },\n                \"complexType\": {\n                    \"original\": \"MenuChangeEventDetail\",\n                    \"resolved\": \"MenuChangeEventDetail\",\n                    \"references\": {\n                        \"MenuChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./menu-interface\",\n                            \"id\": \"src/components/menu/menu-interface.ts::MenuChangeEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"isOpen\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<boolean>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns `true` is the menu is open.\",\n                    \"tags\": []\n                }\n            },\n            \"isActive\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<boolean>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns `true` is the menu is active.\\n\\nA menu is active when it can be opened or closed, meaning it's enabled\\nand it's not part of a `ion-split-pane`.\",\n                    \"tags\": []\n                }\n            },\n            \"open\": {\n                \"complexType\": {\n                    \"signature\": \"(animated?: boolean) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"animated\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Opens the menu. If the menu is already open or it can't be opened,\\nit returns `false`.\",\n                    \"tags\": []\n                }\n            },\n            \"close\": {\n                \"complexType\": {\n                    \"signature\": \"(animated?: boolean) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"animated\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Closes the menu. If the menu is already closed or it can't be closed,\\nit returns `false`.\",\n                    \"tags\": []\n                }\n            },\n            \"toggle\": {\n                \"complexType\": {\n                    \"signature\": \"(animated?: boolean) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"animated\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Toggles the menu. If the menu is already open, it will try to close, otherwise it will try to open it.\\nIf the operation can't be completed successfully, it returns `false`.\",\n                    \"tags\": []\n                }\n            },\n            \"setOpen\": {\n                \"complexType\": {\n                    \"signature\": \"(shouldOpen: boolean, animated?: boolean) => Promise<boolean>\",\n                    \"parameters\": [{\n                            \"name\": \"shouldOpen\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }, {\n                            \"name\": \"animated\",\n                            \"type\": \"boolean\",\n                            \"docs\": \"\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<boolean>\"\n                },\n                \"docs\": {\n                    \"text\": \"Opens or closes the button.\\nIf the operation can't be completed successfully, it returns `false`.\",\n                    \"tags\": []\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"type\",\n                \"methodName\": \"typeChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }, {\n                \"propName\": \"side\",\n                \"methodName\": \"sideChanged\"\n            }, {\n                \"propName\": \"swipeGesture\",\n                \"methodName\": \"swipeGestureChanged\"\n            }];\n    }\n    static get listeners() {\n        return [{\n                \"name\": \"ionSplitPaneVisible\",\n                \"method\": \"onSplitPaneChanged\",\n                \"target\": \"body\",\n                \"capture\": false,\n                \"passive\": false\n            }, {\n                \"name\": \"click\",\n                \"method\": \"onBackdropClick\",\n                \"target\": undefined,\n                \"capture\": true,\n                \"passive\": false\n            }];\n    }\n}\nconst computeDelta = (deltaX, isOpen, isEndSide) => {\n    return Math.max(0, isOpen !== isEndSide ? -deltaX : deltaX);\n};\nconst checkEdgeSide = (win, posX, isEndSide, maxEdgeStart) => {\n    if (isEndSide) {\n        return posX >= win.innerWidth - maxEdgeStart;\n    }\n    else {\n        return posX <= maxEdgeStart;\n    }\n};\nconst SHOW_MENU = 'show-menu';\nconst SHOW_BACKDROP = 'show-backdrop';\nconst MENU_CONTENT_OPEN = 'menu-content-open';\n"],"version":3}