{"file":"ion-range.entry.cjs.js","mappings":"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","names":["clamp","debounceEvent","printIonWarning","inheritAriaAttributes","findClosestIonContent","disableContentScrollY","resetContentScrollY","isRTL","h","hostContext","getIonMode","renderHiddenInput","Host","createColorClasses"],"sources":["node_modules/@ionic/core/dist/collection/utils/floating-point/index.js","node_modules/@ionic/core/dist/collection/components/range/range.ios.css?tag=ion-range&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.md.css?tag=ion-range&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/range/range.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport function getDecimalPlaces(n) {\n    if (n % 1 === 0)\n        return 0;\n    return n.toString().split('.')[1].length;\n}\n/**\n * Fixes floating point rounding errors in a result by rounding\n * to the same specificity, or number of decimal places (*not*\n * significant figures) as provided reference numbers. If multiple\n * references are provided, the highest number of decimal places\n * between them will be used.\n *\n * The main use case is when numbers x and y are added to produce n,\n * but x and y are floats, so n may have rounding errors (such as\n * 3.1000000004 instead of 3.1). As long as only addition/subtraction\n * occurs between x and y, the specificity of the result will never\n * increase, so x and y should be passed in as the references.\n *\n * If multiplication, division, or other operations were used to\n * calculate n, the rounded result may have less specificity than\n * desired. For example, 1 / 3 = 0.33333(...), but\n * roundToMaxDecimalPlaces((1 / 3), 1, 3) will return 0, since both\n * 1 and 3 are whole numbers.\n *\n * Note that extremely precise reference numbers may lead to rounding\n * errors not being trimmed, due to the error result having the same or\n * fewer decimal places as the reference(s). This is acceptable as we\n * would not be able to tell the difference between a rounding error\n * and correct value in this case, but it does mean there is an implicit\n * precision limit. If precision that high is needed, it is recommended\n * to use a third party data type designed to handle floating point\n * errors instead.\n *\n * @param n The number to round.\n * @param references Number(s) used to calculate n, or that should otherwise\n * be used as a reference for the desired specificity.\n */\nexport function roundToMaxDecimalPlaces(n, ...references) {\n    const maxPlaces = Math.max(...references.map((r) => getDecimalPlaces(r)));\n    return Number(n.toFixed(maxPlaces));\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n.range-knob-handle {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n.range-bar-container {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n.range-knob {\n  inset-inline-start: calc(50% - var(--knob-size) / 2);\n}\n\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 24px was chosen so the knob and its\n * shadow do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: #ffffff;\n  --knob-box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 6px 13px rgba(0, 0, 0, 0.12);\n  --knob-size: 26px;\n  --bar-height: 4px;\n  --bar-background: var(--ion-color-step-900, var(--ion-background-color-step-900, #e6e6e6));\n  --bar-background-active: var(--ion-color-primary, #0054e9);\n  --bar-border-radius: 2px;\n  --height: 42px;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 24px;\n  padding-inline-start: 24px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 24px;\n  padding-inline-end: 24px;\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active {\n  background: var(--ion-color-base);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: calc(8px + 0.75rem);\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: calc(8px + 0.75rem);\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n.range-bar-active.has-ticks {\n  border-radius: 0;\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  -webkit-margin-end: -2px;\n  margin-inline-end: -2px;\n}\n\n.range-tick {\n  -webkit-margin-start: -2px;\n  margin-inline-start: -2px;\n  border-radius: 0;\n  position: absolute;\n  top: 17px;\n  width: 4px;\n  height: 8px;\n  background: var(--ion-color-step-900, var(--ion-background-color-step-900, #e6e6e6));\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: var(--bar-background-active);\n}\n\n.range-pin {\n  transform: translate3d(0,  100%,  0) scale(0.01);\n  -webkit-padding-start: 8px;\n  padding-inline-start: 8px;\n  -webkit-padding-end: 8px;\n  padding-inline-end: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  min-width: 28px;\n  transition: transform 120ms ease;\n  background: transparent;\n  color: var(--ion-text-color, #000);\n  font-size: 0.75rem;\n  text-align: center;\n}\n\n/**\n * The -100% ensures the pin sits on top\n * of the range-knob-handle container.\n * We apply 11px so that the pin\n * text is closer to the knob inside of the container.\n * We also apply the 11px here instead of using \"top\"\n * otherwise the pin text will translate below the knob\n * when the text is scaled.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 11px), 0) scale(1);\n}\n\n:host(.range-disabled) {\n  opacity: 0.3;\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n  margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  display: flex;\n  position: absolute;\n  justify-content: center;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n.range-knob-handle {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob-handle:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar-container {\n  border-radius: var(--bar-border-radius);\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n}\n.range-bar-container {\n  inset-inline-start: 0;\n}\n\n:host-context([dir=rtl]) .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-bar-container {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-bar-container:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n.range-knob {\n  inset-inline-start: calc(50% - var(--knob-size) / 2);\n}\n\n:host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-knob:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n/**\n * Range can be slotted\n * in components such as item and\n * toolbar which is why we do not\n * limit the below behavior to just ion-item.\n */\n:host([slot=start]),\n:host([slot=end]) {\n  width: auto;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n.range-wrapper {\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  align-items: center;\n  height: inherit;\n}\n\n::slotted([slot=label]) {\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   * However, we do not set the max\n   * width to 100% because then\n   * only the label would show and users\n   * would not be able to see the range.\n   */\n  max-width: 200px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n/**\n * If no label text is placed into the slot\n * then the element should be hidden otherwise\n * there will be additional margins added.\n */\n.label-text-wrapper-hidden {\n  display: none;\n}\n\n.native-wrapper {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL.\n */\n:host(.range-label-placement-start) .range-wrapper {\n  flex-direction: row;\n}\n\n:host(.range-label-placement-start) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the right of the range in LTR and\n * on the left in RTL.\n */\n:host(.range-label-placement-end) .range-wrapper {\n  flex-direction: row-reverse;\n}\n\n/**\n * The margin between the label and\n * the range should be on the start\n * when the label sits at the end.\n */\n:host(.range-label-placement-end) .label-text-wrapper {\n  -webkit-margin-start: 16px;\n  margin-inline-start: 16px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  /**\n   * The margin between the label and\n   * the range should be on the end\n   * when the label sits at the start.\n   */\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 16px;\n  margin-inline-end: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n/**\n * Label is on the left of the range in LTR and\n * on the right in RTL. Label also has a fixed width.\n */\n:host(.range-label-placement-fixed) .label-text-wrapper {\n  flex: 0 0 100px;\n  width: 100px;\n  min-width: 100px;\n  max-width: 200px;\n}\n\n/**\n * Label is on top of the range.\n */\n:host(.range-label-placement-stacked) .range-wrapper {\n  flex-direction: column;\n  align-items: stretch;\n}\n\n:host(.range-label-placement-stacked) .label-text-wrapper {\n  transform-origin: left top;\n  transform: scale(0.75);\n  /**\n  * The margin between the label and\n  * the range should be on the bottom\n  * when the label sits on top.\n  */\n  margin-left: 0;\n  margin-right: 0;\n  margin-bottom: 16px;\n  /**\n   * Label text should not extend\n   * beyond the bounds of the range.\n   */\n  max-width: calc(100% / 0.75);\n}\n:host-context([dir=rtl]):host(.range-label-placement-stacked) .label-text-wrapper, :host-context([dir=rtl]).range-label-placement-stacked .label-text-wrapper {\n  transform-origin: right top;\n}\n\n@supports selector(:dir(rtl)) {\n  :host(.range-label-placement-stacked:dir(rtl)) .label-text-wrapper {\n    transform-origin: right top;\n  }\n}\n\n:host(.in-item.range-label-placement-stacked) .label-text-wrapper {\n  margin-top: 10px;\n  margin-bottom: 16px;\n}\n\n:host(.in-item.range-label-placement-stacked) .native-wrapper {\n  margin-bottom: 0px;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * 18px was chosen so the knob and its focus/active\n * effects do not get cut off by the item.\n */\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: var(--bar-background-active);\n  --knob-box-shadow: none;\n  --knob-size: 18px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-color-primary-rgb, 0, 84, 233), 0.26);\n  --bar-background-active: var(--ion-color-primary, #0054e9);\n  --bar-border-radius: 0;\n  --height: 42px;\n  --pin-background: var(--ion-color-primary, #0054e9);\n  --pin-color: var(--ion-color-primary-contrast, #fff);\n}\n\n::slotted(:not(ion-icon)[slot=start]),\n::slotted(:not(ion-icon)[slot=end]),\n.native-wrapper {\n  font-size: 0.75rem;\n}\n\n:host(.range-item-start-adjustment) {\n  -webkit-padding-start: 18px;\n  padding-inline-start: 18px;\n}\n\n:host(.range-item-end-adjustment) {\n  -webkit-padding-end: 18px;\n  padding-inline-end: 18px;\n}\n\n:host(.ion-color) .range-bar {\n  background: rgba(var(--ion-color-base-rgb), 0.26);\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-knob::before,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n::slotted([slot=start]) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 14px;\n  margin-inline-end: 14px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n::slotted([slot=end]) {\n  -webkit-margin-start: 14px;\n  margin-inline-start: 14px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n:host(.range-has-pin:not(.range-label-placement-stacked)) {\n  /**\n  * The pin should not overlap any elements that are\n  * above the range. By adding padding to the top of the\n  * range, it provides a buffer for the pin to move into\n  * when it is pressed.\n  *\n  * The padding is not included when the label is stacked\n  * because the pin is below the label.\n  * It still requires a buffer to prevent the pin from\n  * overlapping the range. The buffer is added to the\n  * bottom of the range label instead of the host.\n  */\n  padding-top: 1.75rem;\n}\n\n:host(.range-has-pin.range-label-placement-stacked) .label-text-wrapper {\n  /**\n  * The pin should not overlap the stacked label. By adding\n  * margin to the bottom of the label, it provides a buffer\n  * for the pin to move into when it is pressed.\n  */\n  margin-bottom: 1.75rem;\n}\n\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-knob {\n  transform: scale(0.67);\n  transition-duration: 120ms;\n  transition-property: transform, background-color, border;\n  transition-timing-function: ease;\n  z-index: 2;\n}\n.range-knob::before {\n  border-radius: 50%;\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  transform: scale(1);\n  transition: 0.267s cubic-bezier(0, 0, 0.58, 1);\n  background: var(--knob-background);\n  content: \"\";\n  opacity: 0.13;\n  pointer-events: none;\n}\n.range-knob::before {\n  inset-inline-start: 0;\n}\n\n.range-tick {\n  position: absolute;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  width: var(--bar-height);\n  height: var(--bar-height);\n  background: var(--bar-background-active);\n  z-index: 1;\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: transparent;\n}\n\n.range-pin {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  border-radius: 50%;\n  transform: translate3d(0,  0,  0) scale(0.01);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /**\n   * The dimensions of the range need\n   * to scale with the size of the text\n   * which is why we use dynamic dimensions here.\n   */\n  width: 1.75rem;\n  height: 1.75rem;\n  transition: transform 120ms ease, background 120ms ease;\n  background: var(--pin-background);\n  color: var(--pin-color);\n}\n.range-pin::before {\n  /**\n   * The -1px here moves the ::before\n   * psuedo-element down to create a uniform pin shape.\n   */\n  bottom: -1px;\n  -webkit-margin-start: -13px;\n  margin-inline-start: -13px;\n  /* stylelint-disable-next-line property-disallowed-list */\n  border-radius: 50% 50% 50% 0;\n  position: absolute;\n  width: 26px;\n  height: 26px;\n  transform: rotate(-45deg);\n  transition: background 120ms ease;\n  background: var(--pin-background);\n  content: \"\";\n  z-index: -1;\n}\n.range-pin::before {\n  inset-inline-start: 50%;\n}\n\n:host-context([dir=rtl]) .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n[dir=rtl] .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n@supports selector(:dir(rtl)) {\n  .range-pin::before:dir(rtl) {\n    /* stylelint-disable-next-line property-disallowed-list */\n    left: unset;\n  }\n}\n\n/**\n * Move the pin up by its full height\n * plus a few pixels so the tip is above\n * (but not touching) the knob.\n */\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0, calc(-100% + 4px), 0) scale(1);\n}\n\n@media (any-hover: hover) {\n  .range-knob-handle:hover .range-knob:before {\n    transform: scale(2);\n    opacity: 0.13;\n  }\n}\n.range-knob-handle.ion-activated .range-knob:before, .range-knob-handle.ion-focused .range-knob:before, .range-knob-handle.range-knob-pressed .range-knob:before {\n  transform: scale(2);\n}\n.range-knob-handle.ion-focused .range-knob::before {\n  opacity: 0.13;\n}\n.range-knob-handle.ion-activated .range-knob::before, .range-knob-handle.range-knob-pressed .range-knob::before {\n  opacity: 0.25;\n}\n\n:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,\n:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob {\n  transform: scale(1);\n}\n\n:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick {\n  background-color: var(--ion-color-step-250, var(--ion-background-color-step-250, #bfbfbf));\n}\n\n:host(.range-disabled) .range-knob {\n  transform: scale(0.55);\n  outline: 5px solid #fff;\n  background-color: var(--ion-color-step-250, var(--ion-background-color-step-250, #bfbfbf));\n}\n\n:host(.range-disabled) .label-text-wrapper,\n:host(.range-disabled) ::slotted([slot=start]),\n:host(.range-disabled) ::slotted([slot=end]) {\n  opacity: 0.38;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { findClosestIonContent, disableContentScrollY, resetContentScrollY } from \"../../utils/content/index\";\nimport { inheritAriaAttributes, clamp, debounceEvent, renderHiddenInput } from \"../../utils/helpers\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\nimport { roundToMaxDecimalPlaces } from \"../../utils/floating-point\";\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot label - The label text to associate with the range. Use the \"labelPlacement\" property to control where the label is placed relative to the range.\n * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.\n * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.\n *\n * @part tick - An inactive tick mark.\n * @part tick-active - An active tick mark.\n * @part pin - The counter that appears above a knob.\n * @part knob - The handle that is used to drag the range.\n * @part bar - The inactive part of the bar.\n * @part bar-active - The active part of the bar.\n * @part label - The label text describing the range.\n */\nexport class Range {\n    constructor() {\n        this.rangeId = `ion-r-${rangeIds++}`;\n        this.didLoad = false;\n        this.noUpdate = false;\n        this.hasFocus = false;\n        this.inheritedAttributes = {};\n        this.contentEl = null;\n        this.initialContentScrollY = true;\n        this.clampBounds = (value) => {\n            return clamp(this.min, value, this.max);\n        };\n        this.ensureValueInBounds = (value) => {\n            if (this.dualKnobs) {\n                return {\n                    lower: this.clampBounds(value.lower),\n                    upper: this.clampBounds(value.upper),\n                };\n            }\n            else {\n                return this.clampBounds(value);\n            }\n        };\n        this.setupGesture = async () => {\n            const rangeSlider = this.rangeSlider;\n            if (rangeSlider) {\n                this.gesture = (await import('../../utils/gesture')).createGesture({\n                    el: rangeSlider,\n                    gestureName: 'range',\n                    gesturePriority: 100,\n                    /**\n                     * Provide a threshold since the drag movement\n                     * might be a user scrolling the view.\n                     * If this is true, then the range\n                     * should not move.\n                     */\n                    threshold: 10,\n                    onStart: () => this.onStart(),\n                    onMove: (ev) => this.onMove(ev),\n                    onEnd: (ev) => this.onEnd(ev),\n                });\n                this.gesture.enable(!this.disabled);\n            }\n        };\n        this.handleKeyboard = (knob, isIncrease) => {\n            const { ensureValueInBounds } = this;\n            let step = this.step;\n            step = step > 0 ? step : 1;\n            step = step / (this.max - this.min);\n            if (!isIncrease) {\n                step *= -1;\n            }\n            if (knob === 'A') {\n                this.ratioA = clamp(0, this.ratioA + step, 1);\n            }\n            else {\n                this.ratioB = clamp(0, this.ratioB + step, 1);\n            }\n            this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });\n            this.updateValue();\n            this.emitValueChange();\n            this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });\n        };\n        this.onBlur = () => {\n            if (this.hasFocus) {\n                this.hasFocus = false;\n                this.ionBlur.emit();\n            }\n        };\n        this.onFocus = () => {\n            if (!this.hasFocus) {\n                this.hasFocus = true;\n                this.ionFocus.emit();\n            }\n        };\n        this.ratioA = 0;\n        this.ratioB = 0;\n        this.pressedKnob = undefined;\n        this.color = undefined;\n        this.debounce = undefined;\n        this.name = this.rangeId;\n        this.label = undefined;\n        this.dualKnobs = false;\n        this.min = 0;\n        this.max = 100;\n        this.pin = false;\n        this.pinFormatter = (value) => Math.round(value);\n        this.snaps = false;\n        this.step = 1;\n        this.ticks = true;\n        this.activeBarStart = undefined;\n        this.disabled = false;\n        this.value = 0;\n        this.labelPlacement = 'start';\n    }\n    debounceChanged() {\n        const { ionInput, debounce, originalIonInput } = this;\n        /**\n         * If debounce is undefined, we have to manually revert the ionInput emitter in case\n         * debounce used to be set to a number. Otherwise, the event would stay debounced.\n         */\n        this.ionInput = debounce === undefined ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce);\n    }\n    minChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    maxChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    activeBarStartChanged() {\n        const { activeBarStart } = this;\n        if (activeBarStart !== undefined) {\n            if (activeBarStart > this.max) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.max;\n            }\n            else if (activeBarStart < this.min) {\n                printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n                this.activeBarStart = this.min;\n            }\n        }\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    valueChanged() {\n        if (!this.noUpdate) {\n            this.updateRatio();\n        }\n    }\n    componentWillLoad() {\n        /**\n         * If user has custom ID set then we should\n         * not assign the default incrementing ID.\n         */\n        if (this.el.hasAttribute('id')) {\n            this.rangeId = this.el.getAttribute('id');\n        }\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\n    }\n    componentDidLoad() {\n        this.originalIonInput = this.ionInput;\n        this.setupGesture();\n        this.updateRatio();\n        this.didLoad = true;\n    }\n    connectedCallback() {\n        this.updateRatio();\n        this.debounceChanged();\n        this.disabledChanged();\n        this.activeBarStartChanged();\n        /**\n         * If we have not yet rendered\n         * ion-range, then rangeSlider is not defined.\n         * But if we are moving ion-range via appendChild,\n         * then rangeSlider will be defined.\n         */\n        if (this.didLoad) {\n            this.setupGesture();\n        }\n        this.contentEl = findClosestIonContent(this.el);\n    }\n    disconnectedCallback() {\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    getValue() {\n        var _a;\n        const value = (_a = this.value) !== null && _a !== void 0 ? _a : 0;\n        if (this.dualKnobs) {\n            if (typeof value === 'object') {\n                return value;\n            }\n            return {\n                lower: 0,\n                upper: value,\n            };\n        }\n        else {\n            if (typeof value === 'object') {\n                return value.upper;\n            }\n            return value;\n        }\n    }\n    /**\n     * Emits an `ionChange` event.\n     *\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitValueChange() {\n        this.value = this.ensureValueInBounds(this.value);\n        this.ionChange.emit({ value: this.value });\n    }\n    /**\n     * The value should be updated on touch end or\n     * when the component is being dragged.\n     * This follows the native behavior of mobile devices.\n     *\n     * For example: When the user lifts their finger from the\n     * screen after tapping the bar or dragging the bar or knob.\n     */\n    onStart() {\n        this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    /**\n     * The value should be updated while dragging the\n     * bar or knob.\n     *\n     * While the user is dragging, the view\n     * should not scroll. This is to prevent the user from\n     * feeling disoriented while dragging.\n     *\n     * The user can scroll on the view if the knob or\n     * bar is not being dragged.\n     *\n     * @param detail The details of the gesture event.\n     */\n    onMove(detail) {\n        const { contentEl, pressedKnob } = this;\n        const currentX = detail.currentX;\n        /**\n         * Since the user is dragging on the bar or knob, the view should not scroll.\n         *\n         * This only needs to be done once.\n         */\n        if (contentEl && this.initialContentScrollY === undefined) {\n            this.initialContentScrollY = disableContentScrollY(contentEl);\n        }\n        /**\n         * The `pressedKnob` can be undefined if the user just\n         * started dragging the knob.\n         *\n         * This is necessary to determine which knob the user is dragging,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         *\n         * This only needs to be done once since the knob won't change\n         * while the user is dragging.\n         */\n        if (pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        this.update(currentX);\n    }\n    /**\n     * The value should be updated on touch end:\n     * - When the user lifts their finger from the screen after\n     * tapping the bar.\n     *\n     * @param detail The details of the gesture or mouse event.\n     */\n    onEnd(detail) {\n        const { contentEl, initialContentScrollY } = this;\n        const currentX = detail.currentX || detail.clientX;\n        /**\n         * The `pressedKnob` can be undefined if the user never\n         * dragged the knob. They just tapped on the bar.\n         *\n         * This is necessary to determine which knob the user is changing,\n         * especially when it's a dual knob.\n         * Plus, it determines when to apply certain styles.\n         */\n        if (this.pressedKnob === undefined) {\n            this.setPressedKnob(currentX);\n        }\n        /**\n         * The user is no longer dragging the bar or\n         * knob (if they were dragging it).\n         *\n         * The user can now scroll on the view in the next gesture event.\n         */\n        if (contentEl && initialContentScrollY !== undefined) {\n            resetContentScrollY(contentEl, initialContentScrollY);\n        }\n        // update the active knob's position\n        this.update(currentX);\n        /**\n         * Reset the pressed knob to undefined since the user\n         * may start dragging a different knob in the next gesture event.\n         */\n        this.pressedKnob = undefined;\n        this.emitValueChange();\n        this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });\n    }\n    update(currentX) {\n        // figure out where the pointer is currently at\n        // update the knob being interacted with\n        const rect = this.rect;\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        if (this.snaps) {\n            // snaps the ratio to the current value\n            ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\n        }\n        // update which knob is pressed\n        if (this.pressedKnob === 'A') {\n            this.ratioA = ratio;\n        }\n        else {\n            this.ratioB = ratio;\n        }\n        // Update input value\n        this.updateValue();\n    }\n    setPressedKnob(currentX) {\n        const rect = (this.rect = this.rangeSlider.getBoundingClientRect());\n        // figure out which knob they started closer to\n        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n        if (isRTL(this.el)) {\n            ratio = 1 - ratio;\n        }\n        this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';\n        this.setFocus(this.pressedKnob);\n    }\n    get valA() {\n        return ratioToValue(this.ratioA, this.min, this.max, this.step);\n    }\n    get valB() {\n        return ratioToValue(this.ratioB, this.min, this.max, this.step);\n    }\n    get ratioLower() {\n        if (this.dualKnobs) {\n            return Math.min(this.ratioA, this.ratioB);\n        }\n        const { activeBarStart } = this;\n        if (activeBarStart == null) {\n            return 0;\n        }\n        return valueToRatio(activeBarStart, this.min, this.max);\n    }\n    get ratioUpper() {\n        if (this.dualKnobs) {\n            return Math.max(this.ratioA, this.ratioB);\n        }\n        return this.ratioA;\n    }\n    updateRatio() {\n        const value = this.getValue();\n        const { min, max } = this;\n        if (this.dualKnobs) {\n            this.ratioA = valueToRatio(value.lower, min, max);\n            this.ratioB = valueToRatio(value.upper, min, max);\n        }\n        else {\n            this.ratioA = valueToRatio(value, min, max);\n        }\n    }\n    updateValue() {\n        this.noUpdate = true;\n        const { valA, valB } = this;\n        this.value = !this.dualKnobs\n            ? valA\n            : {\n                lower: Math.min(valA, valB),\n                upper: Math.max(valA, valB),\n            };\n        this.ionInput.emit({ value: this.value });\n        this.noUpdate = false;\n    }\n    setFocus(knob) {\n        if (this.el.shadowRoot) {\n            const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\n            if (knobEl) {\n                knobEl.focus();\n            }\n        }\n    }\n    /**\n     * Returns true if content was passed to the \"start\" slot\n     */\n    get hasStartSlotContent() {\n        return this.el.querySelector('[slot=\"start\"]') !== null;\n    }\n    /**\n     * Returns true if content was passed to the \"end\" slot\n     */\n    get hasEndSlotContent() {\n        return this.el.querySelector('[slot=\"end\"]') !== null;\n    }\n    get hasLabel() {\n        return this.label !== undefined || this.el.querySelector('[slot=\"label\"]') !== null;\n    }\n    renderRangeSlider() {\n        var _a;\n        const { min, max, step, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, pinFormatter, inheritedAttributes, } = this;\n        let barStart = `${ratioLower * 100}%`;\n        let barEnd = `${100 - ratioUpper * 100}%`;\n        const rtl = isRTL(this.el);\n        const start = rtl ? 'right' : 'left';\n        const end = rtl ? 'left' : 'right';\n        const tickStyle = (tick) => {\n            return {\n                [start]: tick[start],\n            };\n        };\n        if (this.dualKnobs === false) {\n            /**\n             * When the value is less than the activeBarStart or the min value,\n             * the knob will display at the start of the active bar.\n             */\n            if (this.valA < ((_a = this.activeBarStart) !== null && _a !== void 0 ? _a : this.min)) {\n                /**\n                 * Sets the bar positions relative to the upper and lower limits.\n                 * Converts the ratio values into percentages, used as offsets for left/right styles.\n                 *\n                 * The ratioUpper refers to the knob position on the bar.\n                 * The ratioLower refers to the end position of the active bar (the value).\n                 */\n                barStart = `${ratioUpper * 100}%`;\n                barEnd = `${100 - ratioLower * 100}%`;\n            }\n            else {\n                /**\n                 * Otherwise, the knob will display at the end of the active bar.\n                 *\n                 * The ratioLower refers to the start position of the active bar (the value).\n                 * The ratioUpper refers to the knob position on the bar.\n                 */\n                barStart = `${ratioLower * 100}%`;\n                barEnd = `${100 - ratioUpper * 100}%`;\n            }\n        }\n        const barStyle = {\n            [start]: barStart,\n            [end]: barEnd,\n        };\n        const ticks = [];\n        if (this.snaps && this.ticks) {\n            for (let value = min; value <= max; value += step) {\n                const ratio = valueToRatio(value, min, max);\n                const ratioMin = Math.min(ratioLower, ratioUpper);\n                const ratioMax = Math.max(ratioLower, ratioUpper);\n                const tick = {\n                    ratio,\n                    /**\n                     * Sets the tick mark as active when the tick is between the min bounds and the knob.\n                     * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.\n                     */\n                    active: ratio >= ratioMin && ratio <= ratioMax,\n                };\n                tick[start] = `${ratio * 100}%`;\n                ticks.push(tick);\n            }\n        }\n        return (h(\"div\", { class: \"range-slider\", ref: (rangeEl) => (this.rangeSlider = rangeEl),\n            /**\n             * Since the gesture has a threshold, the value\n             * won't change until the user has dragged past\n             * the threshold. This is to prevent the range\n             * from moving when the user is scrolling.\n             *\n             * This results in the value not being updated\n             * and the event emitters not being triggered\n             * if the user taps on the range. This is why\n             * we need to listen for the \"pointerUp\" event.\n             */\n            onPointerUp: (ev) => {\n                /**\n                 * If the user drags the knob on the web\n                 * version (does not occur on mobile),\n                 * the \"pointerUp\" event will be triggered\n                 * along with the gesture's events.\n                 * This leads to duplicate events.\n                 *\n                 * By checking if the pressedKnob is undefined,\n                 * we can determine if the \"pointerUp\" event was\n                 * triggered by a tap or a drag. If it was\n                 * dragged, the pressedKnob will be defined.\n                 */\n                if (this.pressedKnob === undefined) {\n                    this.onStart();\n                    this.onEnd(ev);\n                }\n            } }, ticks.map((tick) => (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\n                'range-tick': true,\n                'range-tick-active': tick.active,\n            }, part: tick.active ? 'tick-active' : 'tick' }))), h(\"div\", { class: \"range-bar-container\" }, h(\"div\", { class: \"range-bar\", role: \"presentation\", part: \"bar\" }), h(\"div\", { class: {\n                'range-bar': true,\n                'range-bar-active': true,\n                'has-ticks': ticks.length > 0,\n            }, role: \"presentation\", style: barStyle, part: \"bar-active\" })), renderKnob(rtl, {\n            knob: 'A',\n            pressed: pressedKnob === 'A',\n            value: this.valA,\n            ratio: this.ratioA,\n            pin,\n            pinFormatter,\n            disabled,\n            handleKeyboard,\n            min,\n            max,\n            inheritedAttributes,\n        }), this.dualKnobs &&\n            renderKnob(rtl, {\n                knob: 'B',\n                pressed: pressedKnob === 'B',\n                value: this.valB,\n                ratio: this.ratioB,\n                pin,\n                pinFormatter,\n                disabled,\n                handleKeyboard,\n                min,\n                max,\n                inheritedAttributes,\n            })));\n    }\n    render() {\n        const { disabled, el, hasLabel, rangeId, pin, pressedKnob, labelPlacement, label } = this;\n        const inItem = hostContext('ion-item', el);\n        /**\n         * If there is no start content then the knob at\n         * the min value will be cut off by the item margin.\n         */\n        const hasStartContent = (hasLabel && (labelPlacement === 'start' || labelPlacement === 'fixed')) || this.hasStartSlotContent;\n        const needsStartAdjustment = inItem && !hasStartContent;\n        /**\n         * If there is no end content then the knob at\n         * the max value will be cut off by the item margin.\n         */\n        const hasEndContent = (hasLabel && labelPlacement === 'end') || this.hasEndSlotContent;\n        const needsEndAdjustment = inItem && !hasEndContent;\n        const mode = getIonMode(this);\n        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n        return (h(Host, { key: 'cd70b5db9eae808a644643d7095a1b5264cbc5fe', onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-item': inItem,\n                'range-disabled': disabled,\n                'range-pressed': pressedKnob !== undefined,\n                'range-has-pin': pin,\n                [`range-label-placement-${labelPlacement}`]: true,\n                'range-item-start-adjustment': needsStartAdjustment,\n                'range-item-end-adjustment': needsEndAdjustment,\n            }) }, h(\"label\", { key: '78ef0523f0064d6b268ae17ef72f90094511d897', class: \"range-wrapper\", id: \"range-label\" }, h(\"div\", { key: '6e4b2051e770dabe80dcb9f412e9aae1859e9f33', class: {\n                'label-text-wrapper': true,\n                'label-text-wrapper-hidden': !hasLabel,\n            }, part: \"label\" }, label !== undefined ? h(\"div\", { class: \"label-text\" }, label) : h(\"slot\", { name: \"label\" })), h(\"div\", { key: '72cdb8f6657a3b84f759743cedd600020c954c6a', class: \"native-wrapper\" }, h(\"slot\", { key: 'f7a38d6bd63df5dc8b4470f1f4acaaf3e5c80514', name: \"start\" }), this.renderRangeSlider(), h(\"slot\", { key: 'ae74ac8c1da691e3be1b2f00dfd3c8419b9566ec', name: \"end\" })))));\n    }\n    static get is() { return \"ion-range\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"range.ios.scss\"],\n            \"md\": [\"range.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"range.ios.css\"],\n            \"md\": [\"range.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"debounce\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"How long, in milliseconds, to wait to trigger the\\n`ionInput` event after each change in the range value.\"\n                },\n                \"attribute\": \"debounce\",\n                \"reflect\": false\n            },\n            \"name\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The name of the control, which is submitted with the form data.\"\n                },\n                \"attribute\": \"name\",\n                \"reflect\": false,\n                \"defaultValue\": \"this.rangeId\"\n            },\n            \"label\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"string\",\n                    \"resolved\": \"string | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The text to display as the control's label. Use this over the `label` slot if\\nyou only need plain text. The `label` property will take priority over the\\n`label` slot if both are used.\"\n                },\n                \"attribute\": \"label\",\n                \"reflect\": false\n            },\n            \"dualKnobs\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Show two knobs.\"\n                },\n                \"attribute\": \"dual-knobs\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"min\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Minimum integer value of the range.\"\n                },\n                \"attribute\": \"min\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"max\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Maximum integer value of the range.\"\n                },\n                \"attribute\": \"max\",\n                \"reflect\": false,\n                \"defaultValue\": \"100\"\n            },\n            \"pin\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, a pin with integer value is shown when the knob\\nis pressed.\"\n                },\n                \"attribute\": \"pin\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"pinFormatter\": {\n                \"type\": \"unknown\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"PinFormatter\",\n                    \"resolved\": \"(value: number) => string | number\",\n                    \"references\": {\n                        \"PinFormatter\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::PinFormatter\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"A callback used to format the pin text.\\nBy default the pin text is set to `Math.round(value)`.\\n\\nSee https://ionicframework.com/docs/troubleshooting/runtime#accessing-this\\nif you need to access `this` from within the callback.\"\n                },\n                \"defaultValue\": \"(value: number): number => Math.round(value)\"\n            },\n            \"snaps\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the knob snaps to tick marks evenly spaced based\\non the step property value.\"\n                },\n                \"attribute\": \"snaps\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"step\": {\n                \"type\": \"number\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Specifies the value granularity.\"\n                },\n                \"attribute\": \"step\",\n                \"reflect\": false,\n                \"defaultValue\": \"1\"\n            },\n            \"ticks\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, tick marks are displayed based on the step value.\\nOnly applies when `snaps` is `true`.\"\n                },\n                \"attribute\": \"ticks\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"activeBarStart\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"number\",\n                    \"resolved\": \"number | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The start position of the range active bar. This feature is only available with a single knob (dualKnobs=\\\"false\\\").\\nValid values are greater than or equal to the min value and less than or equal to the max value.\"\n                },\n                \"attribute\": \"active-bar-start\",\n                \"reflect\": false\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the range.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"value\": {\n                \"type\": \"number\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"RangeValue\",\n                    \"resolved\": \"number | { lower: number; upper: number; }\",\n                    \"references\": {\n                        \"RangeValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"the value of the range.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false,\n                \"defaultValue\": \"0\"\n            },\n            \"labelPlacement\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"'start' | 'end' | 'fixed' | 'stacked'\",\n                    \"resolved\": \"\\\"end\\\" | \\\"fixed\\\" | \\\"stacked\\\" | \\\"start\\\"\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Where to place the label relative to the range.\\n`\\\"start\\\"`: The label will appear to the left of the range in LTR and to the right in RTL.\\n`\\\"end\\\"`: The label will appear to the right of the range in LTR and to the left in RTL.\\n`\\\"fixed\\\"`: The label has the same behavior as `\\\"start\\\"` except it also has a fixed width. Long text will be truncated with ellipses (\\\"...\\\").\\n`\\\"stacked\\\"`: The label will appear above the range regardless of the direction.\"\n                },\n                \"attribute\": \"label-placement\",\n                \"reflect\": false,\n                \"defaultValue\": \"'start'\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"ratioA\": {},\n            \"ratioB\": {},\n            \"pressedKnob\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionChange` event is fired for `<ion-range>` elements when the user\\nmodifies the element's value:\\n- When the user releases the knob after dragging;\\n- When the user moves the knob with keyboard arrows\\n\\n`ionChange` is not fired when the value is changed programmatically.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionInput\",\n                \"name\": \"ionInput\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The `ionInput` event is fired for `<ion-range>` elements when the value\\nis modified. Unlike `ionChange`, `ionInput` is fired continuously\\nwhile the user is dragging the knob.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeChangeEventDetail\",\n                    \"resolved\": \"RangeChangeEventDetail\",\n                    \"references\": {\n                        \"RangeChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionFocus\",\n                \"name\": \"ionFocus\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range has focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionBlur\",\n                \"name\": \"ionBlur\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the range loses focus.\"\n                },\n                \"complexType\": {\n                    \"original\": \"void\",\n                    \"resolved\": \"void\",\n                    \"references\": {}\n                }\n            }, {\n                \"method\": \"ionKnobMoveStart\",\n                \"name\": \"ionKnobMoveStart\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user starts moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveStartEventDetail\",\n                    \"resolved\": \"RangeKnobMoveStartEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveStartEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveStartEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionKnobMoveEnd\",\n                \"name\": \"ionKnobMoveEnd\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the user finishes moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n                },\n                \"complexType\": {\n                    \"original\": \"RangeKnobMoveEndEventDetail\",\n                    \"resolved\": \"RangeKnobMoveEndEventDetail\",\n                    \"references\": {\n                        \"RangeKnobMoveEndEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./range-interface\",\n                            \"id\": \"src/components/range/range-interface.ts::RangeKnobMoveEndEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"debounce\",\n                \"methodName\": \"debounceChanged\"\n            }, {\n                \"propName\": \"min\",\n                \"methodName\": \"minChanged\"\n            }, {\n                \"propName\": \"max\",\n                \"methodName\": \"maxChanged\"\n            }, {\n                \"propName\": \"activeBarStart\",\n                \"methodName\": \"activeBarStartChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }];\n    }\n}\nconst renderKnob = (rtl, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, pinFormatter, inheritedAttributes }) => {\n    const start = rtl ? 'right' : 'left';\n    const knobStyle = () => {\n        const style = {};\n        style[start] = `${ratio * 100}%`;\n        return style;\n    };\n    // The aria label should be preferred over visible text if both are specified\n    const ariaLabel = inheritedAttributes['aria-label'];\n    return (h(\"div\", { onKeyDown: (ev) => {\n            const key = ev.key;\n            if (key === 'ArrowLeft' || key === 'ArrowDown') {\n                handleKeyboard(knob, false);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n            else if (key === 'ArrowRight' || key === 'ArrowUp') {\n                handleKeyboard(knob, true);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n        }, class: {\n            'range-knob-handle': true,\n            'range-knob-a': knob === 'A',\n            'range-knob-b': knob === 'B',\n            'range-knob-pressed': pressed,\n            'range-knob-min': value === min,\n            'range-knob-max': value === max,\n            'ion-activatable': true,\n            'ion-focusable': true,\n        }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-label\": ariaLabel !== undefined ? ariaLabel : null, \"aria-labelledby\": ariaLabel === undefined ? 'range-label' : null, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && (h(\"div\", { class: \"range-pin\", role: \"presentation\", part: \"pin\" }, pinFormatter(value))), h(\"div\", { class: \"range-knob\", role: \"presentation\", part: \"knob\" })));\n};\nconst ratioToValue = (ratio, min, max, step) => {\n    let value = (max - min) * ratio;\n    if (step > 0) {\n        // round to nearest multiple of step, then add min\n        value = Math.round(value / step) * step + min;\n    }\n    const clampedValue = clamp(min, value, max);\n    return roundToMaxDecimalPlaces(clampedValue, min, max, step);\n};\nconst valueToRatio = (value, min, max) => {\n    return clamp(0, (value - min) / (max - min), 1);\n};\nlet rangeIds = 0;\n"],"version":3}