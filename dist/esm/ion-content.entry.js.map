{"file":"ion-content.entry.js","mappings":"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","names":[],"sources":["node_modules/@ionic/core/dist/collection/components/content/content.css?tag=ion-content&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/content/content.js"],"sourcesContent":["/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the content\n   *\n   * @prop --color: Color of the content\n   *\n   * @prop --padding-top: Top padding of the content\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the content\n   * @prop --padding-bottom: Bottom padding of the content\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the content\n   *\n   * @prop --keyboard-offset: Keyboard offset of the content\n   *\n   * @prop --offset-top: Offset top of the content\n   * @prop --offset-bottom: Offset bottom of the content\n   */\n  --background: var(--ion-background-color, #fff);\n  --color: var(--ion-text-color, #000);\n  --padding-top: 0px;\n  --padding-bottom: 0px;\n  --padding-start: 0px;\n  --padding-end: 0px;\n  --keyboard-offset: 0px;\n  --offset-top: 0px;\n  --offset-bottom: 0px;\n  --overflow: auto;\n  display: block;\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: 100%;\n  /* stylelint-disable */\n  margin: 0 !important;\n  padding: 0 !important;\n  /* stylelint-enable */\n  font-family: var(--ion-font-family, inherit);\n  contain: size style;\n}\n\n:host(.ion-color) .inner-scroll {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n#background-content {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  position: absolute;\n  background: var(--background);\n}\n\n.inner-scroll {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: calc(var(--padding-top) + var(--offset-top));\n  padding-bottom: calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));\n  position: absolute;\n  color: var(--color);\n  box-sizing: border-box;\n  overflow: hidden;\n  /**\n   * touch-action: manipulation is an alias\n   * for this, but WebKit has an issue\n   * where pointercancel events are not fired\n   * when scrolling: https://bugs.webkit.org/show_bug.cgi?id=240917\n   * Using the long form below avoids the issue.\n   */\n  touch-action: pan-x pan-y pinch-zoom;\n}\n\n.scroll-y,\n.scroll-x {\n  -webkit-overflow-scrolling: touch;\n  /**\n   * This adds `.inner-scroll` as part of the\n   * stacking context in WebKit. Without it,\n   * children of ion-content are treated as\n   * siblings rather than descendants. This\n   * can result in the children being put\n   * into their own layers, degrading\n   * scrolling performance.\n   *\n   * An optimization called \"layer backing\n   * sharing\" usually kicks in to prevent\n   * this, but having translate3d defeats\n   * this optimization.\n   *\n   * See: https://bugs.webkit.org/show_bug.cgi?id=216701\n   */\n  z-index: 0;\n  will-change: scroll-position;\n}\n\n.scroll-y {\n  overflow-y: var(--overflow);\n  overscroll-behavior-y: contain;\n}\n\n.scroll-x {\n  overflow-x: var(--overflow);\n  overscroll-behavior-x: contain;\n}\n\n.overscroll::before,\n.overscroll::after {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  content: \"\";\n}\n\n.overscroll::before {\n  bottom: -1px;\n}\n\n.overscroll::after {\n  top: -1px;\n}\n\n:host(.content-sizing) {\n  display: flex;\n  flex-direction: column;\n  /**\n   * This resolves a sizing issue in popovers where extra long content\n   * would overflow the popover's height, preventing scrolling. It's a\n   * quirk of flexbox that forces the content to shrink to fit.\n   *\n   * overflow: hidden can't be used here because it prevents the visual\n   * effect from showing on translucent headers.\n   */\n  min-height: 0;\n  contain: none;\n}\n\n:host(.content-sizing) .inner-scroll {\n  position: relative;\n  /**\n   * Because the outer content has display: flex here (to help enable\n   * scrolling in a popover), offsetting via `top` (such as when using\n   * a translucent header) creates white space under the content. Use\n   * a negative margin instead to keep the bottom in place. (A similar\n   * thing happens with `bottom` and footers.)\n   */\n  top: 0;\n  bottom: 0;\n  margin-top: calc(var(--offset-top) * -1);\n  margin-bottom: calc(var(--offset-bottom) * -1);\n}\n\n.transition-effect {\n  display: none;\n  position: absolute;\n  width: 100%;\n  height: 100vh;\n  opacity: 0;\n  pointer-events: none;\n}\n\n:host(.content-ltr) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  left: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  right: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n.transition-cover {\n  position: absolute;\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n  width: 100%;\n  height: 100%;\n  background: black;\n  opacity: 0.1;\n}\n\n.transition-shadow {\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  box-shadow: inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);\n}\n\n:host(.content-ltr) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  left: 0;\n  /* stylelint-enable property-disallowed-list */\n  transform: scaleX(-1);\n}\n\n::slotted([slot=fixed]) {\n  position: absolute;\n  /**\n   * When presenting ion-content inside of an ion-modal, the .inner-scroll\n   * element is composited. In WebKit, the fixed content is not composited\n   * causing it to appear under the main scrollable content as a result.\n   * The fixed content is correctly composited in other browsers. Adding\n   * the translateZ forces the fixed content to be composited so it correctly\n   * shows on top of the scrollable content. Setting a negative z-index will\n   * still allow the fixed content to appear under the scroll content if specified.\n   */\n  transform: translateZ(0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Build, Host, forceUpdate, h, readTask } from \"@stencil/core\";\nimport { componentOnReady, hasLazyBuild } from \"../../utils/helpers\";\nimport { isPlatform } from \"../../utils/platform\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\n/**\n * @slot - Content is placed in the scrollable area if provided without a slot.\n * @slot fixed - Should be used for fixed content that should not scroll.\n *\n * @part background - The background of the content.\n * @part scroll - The scrollable container of the content.\n */\nexport class Content {\n    constructor() {\n        this.watchDog = null;\n        this.isScrolling = false;\n        this.lastScroll = 0;\n        this.queued = false;\n        this.cTop = -1;\n        this.cBottom = -1;\n        this.isMainContent = true;\n        this.resizeTimeout = null;\n        this.tabsElement = null;\n        // Detail is used in a hot loop in the scroll event, by allocating it here\n        // V8 will be able to inline any read/write to it since it's a monomorphic class.\n        // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n        this.detail = {\n            scrollTop: 0,\n            scrollLeft: 0,\n            type: 'scroll',\n            event: undefined,\n            startX: 0,\n            startY: 0,\n            startTime: 0,\n            currentX: 0,\n            currentY: 0,\n            velocityX: 0,\n            velocityY: 0,\n            deltaX: 0,\n            deltaY: 0,\n            currentTime: 0,\n            data: undefined,\n            isScrolling: true,\n        };\n        this.color = undefined;\n        this.fullscreen = false;\n        this.forceOverscroll = undefined;\n        this.scrollX = false;\n        this.scrollY = true;\n        this.scrollEvents = false;\n    }\n    connectedCallback() {\n        this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;\n        /**\n         * The fullscreen content offsets need to be\n         * computed after the tab bar has loaded. Since\n         * lazy evaluation means components are not hydrated\n         * at the same time, we need to wait for the ionTabBarLoaded\n         * event to fire. This does not impact dist-custom-elements\n         * because there is no hydration there.\n         */\n        if (hasLazyBuild(this.el)) {\n            /**\n             * We need to cache the reference to the tabs.\n             * If just the content is unmounted then we won't\n             * be able to query for the closest tabs on disconnectedCallback\n             * since the content has been removed from the DOM tree.\n             */\n            const closestTabs = (this.tabsElement = this.el.closest('ion-tabs'));\n            if (closestTabs !== null) {\n                /**\n                 * When adding and removing the event listener\n                 * we need to make sure we pass the same function reference\n                 * otherwise the event listener will not be removed properly.\n                 * We can't only pass `this.resize` because \"this\" in the function\n                 * context becomes a reference to IonTabs instead of IonContent.\n                 *\n                 * Additionally, we listen for ionTabBarLoaded on the IonTabs\n                 * instance rather than the IonTabBar instance. It's possible for\n                 * a tab bar to be conditionally rendered/mounted. Since ionTabBarLoaded\n                 * bubbles, we can catch any instances of child tab bars loading by listening\n                 * on IonTabs.\n                 */\n                this.tabsLoadCallback = () => this.resize();\n                closestTabs.addEventListener('ionTabBarLoaded', this.tabsLoadCallback);\n            }\n        }\n    }\n    disconnectedCallback() {\n        this.onScrollEnd();\n        if (hasLazyBuild(this.el)) {\n            /**\n             * The event listener and tabs caches need to\n             * be cleared otherwise this will create a memory\n             * leak where the IonTabs instance can never be\n             * garbage collected.\n             */\n            const { tabsElement, tabsLoadCallback } = this;\n            if (tabsElement !== null && tabsLoadCallback !== undefined) {\n                tabsElement.removeEventListener('ionTabBarLoaded', tabsLoadCallback);\n            }\n            this.tabsElement = null;\n            this.tabsLoadCallback = undefined;\n        }\n    }\n    /**\n     * Rotating certain devices can update\n     * the safe area insets. As a result,\n     * the fullscreen feature on ion-content\n     * needs to be recalculated.\n     *\n     * We listen for \"resize\" because we\n     * do not care what the orientation of\n     * the device is. Other APIs\n     * such as ScreenOrientation or\n     * the deviceorientation event must have\n     * permission from the user first whereas\n     * the \"resize\" event does not.\n     *\n     * We also throttle the callback to minimize\n     * thrashing when quickly resizing a window.\n     */\n    onResize() {\n        if (this.resizeTimeout) {\n            clearTimeout(this.resizeTimeout);\n            this.resizeTimeout = null;\n        }\n        this.resizeTimeout = setTimeout(() => {\n            /**\n             * Resize should only happen\n             * if the content is visible.\n             * When the content is hidden\n             * then offsetParent will be null.\n             */\n            if (this.el.offsetParent === null) {\n                return;\n            }\n            this.resize();\n        }, 100);\n    }\n    shouldForceOverscroll() {\n        const { forceOverscroll } = this;\n        const mode = getIonMode(this);\n        return forceOverscroll === undefined ? mode === 'ios' && isPlatform('ios') : forceOverscroll;\n    }\n    resize() {\n        /**\n         * Only force update if the component is rendered in a browser context.\n         * Using `forceUpdate` in a server context with pre-rendering can lead to an infinite loop.\n         * The `hydrateDocument` function in `@stencil/core` will render the `ion-content`, but\n         * `forceUpdate` will trigger another render, locking up the server.\n         *\n         * TODO: Remove if STENCIL-834 determines Stencil will account for this.\n         */\n        if (Build.isBrowser) {\n            if (this.fullscreen) {\n                readTask(() => this.readDimensions());\n            }\n            else if (this.cTop !== 0 || this.cBottom !== 0) {\n                this.cTop = this.cBottom = 0;\n                forceUpdate(this);\n            }\n        }\n    }\n    readDimensions() {\n        const page = getPageElement(this.el);\n        const top = Math.max(this.el.offsetTop, 0);\n        const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);\n        const dirty = top !== this.cTop || bottom !== this.cBottom;\n        if (dirty) {\n            this.cTop = top;\n            this.cBottom = bottom;\n            forceUpdate(this);\n        }\n    }\n    onScroll(ev) {\n        const timeStamp = Date.now();\n        const shouldStart = !this.isScrolling;\n        this.lastScroll = timeStamp;\n        if (shouldStart) {\n            this.onScrollStart();\n        }\n        if (!this.queued && this.scrollEvents) {\n            this.queued = true;\n            readTask((ts) => {\n                this.queued = false;\n                this.detail.event = ev;\n                updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);\n                this.ionScroll.emit(this.detail);\n            });\n        }\n    }\n    /**\n     * Get the element where the actual scrolling takes place.\n     * This element can be used to subscribe to `scroll` events or manually modify\n     * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:\n     *\n     * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\n     * and `scrollToPoint()` to scroll the content into a certain point.\n     */\n    async getScrollElement() {\n        /**\n         * If this gets called in certain early lifecycle hooks (ex: Vue onMounted),\n         * scrollEl won't be defined yet with the custom elements build, so wait for it to load in.\n         */\n        if (!this.scrollEl) {\n            await new Promise((resolve) => componentOnReady(this.el, resolve));\n        }\n        return Promise.resolve(this.scrollEl);\n    }\n    /**\n     * Returns the background content element.\n     * @internal\n     */\n    async getBackgroundElement() {\n        if (!this.backgroundContentEl) {\n            await new Promise((resolve) => componentOnReady(this.el, resolve));\n        }\n        return Promise.resolve(this.backgroundContentEl);\n    }\n    /**\n     * Scroll to the top of the component.\n     *\n     * @param duration The amount of time to take scrolling to the top. Defaults to `0`.\n     */\n    scrollToTop(duration = 0) {\n        return this.scrollToPoint(undefined, 0, duration);\n    }\n    /**\n     * Scroll to the bottom of the component.\n     *\n     * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.\n     */\n    async scrollToBottom(duration = 0) {\n        const scrollEl = await this.getScrollElement();\n        const y = scrollEl.scrollHeight - scrollEl.clientHeight;\n        return this.scrollToPoint(undefined, y, duration);\n    }\n    /**\n     * Scroll by a specified X/Y distance in the component.\n     *\n     * @param x The amount to scroll by on the horizontal axis.\n     * @param y The amount to scroll by on the vertical axis.\n     * @param duration The amount of time to take scrolling by that amount.\n     */\n    async scrollByPoint(x, y, duration) {\n        const scrollEl = await this.getScrollElement();\n        return this.scrollToPoint(x + scrollEl.scrollLeft, y + scrollEl.scrollTop, duration);\n    }\n    /**\n     * Scroll to a specified X/Y location in the component.\n     *\n     * @param x The point to scroll to on the horizontal axis.\n     * @param y The point to scroll to on the vertical axis.\n     * @param duration The amount of time to take scrolling to that point. Defaults to `0`.\n     */\n    async scrollToPoint(x, y, duration = 0) {\n        const el = await this.getScrollElement();\n        if (duration < 32) {\n            if (y != null) {\n                el.scrollTop = y;\n            }\n            if (x != null) {\n                el.scrollLeft = x;\n            }\n            return;\n        }\n        let resolve;\n        let startTime = 0;\n        const promise = new Promise((r) => (resolve = r));\n        const fromY = el.scrollTop;\n        const fromX = el.scrollLeft;\n        const deltaY = y != null ? y - fromY : 0;\n        const deltaX = x != null ? x - fromX : 0;\n        // scroll loop\n        const step = (timeStamp) => {\n            const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;\n            const easedT = Math.pow(linearTime, 3) + 1;\n            if (deltaY !== 0) {\n                el.scrollTop = Math.floor(easedT * deltaY + fromY);\n            }\n            if (deltaX !== 0) {\n                el.scrollLeft = Math.floor(easedT * deltaX + fromX);\n            }\n            if (easedT < 1) {\n                // do not use DomController here\n                // must use nativeRaf in order to fire in the next frame\n                requestAnimationFrame(step);\n            }\n            else {\n                resolve();\n            }\n        };\n        // chill out for a frame first\n        requestAnimationFrame((ts) => {\n            startTime = ts;\n            step(ts);\n        });\n        return promise;\n    }\n    onScrollStart() {\n        this.isScrolling = true;\n        this.ionScrollStart.emit({\n            isScrolling: true,\n        });\n        if (this.watchDog) {\n            clearInterval(this.watchDog);\n        }\n        // watchdog\n        this.watchDog = setInterval(() => {\n            if (this.lastScroll < Date.now() - 120) {\n                this.onScrollEnd();\n            }\n        }, 100);\n    }\n    onScrollEnd() {\n        if (this.watchDog)\n            clearInterval(this.watchDog);\n        this.watchDog = null;\n        if (this.isScrolling) {\n            this.isScrolling = false;\n            this.ionScrollEnd.emit({\n                isScrolling: false,\n            });\n        }\n    }\n    render() {\n        const { isMainContent, scrollX, scrollY, el } = this;\n        const rtl = isRTL(el) ? 'rtl' : 'ltr';\n        const mode = getIonMode(this);\n        const forceOverscroll = this.shouldForceOverscroll();\n        const transitionShadow = mode === 'ios';\n        this.resize();\n        return (h(Host, { key: '98e9658e69c0bbe0113e4c1b89dd7b240334c039', role: isMainContent ? 'main' : undefined, class: createColorClasses(this.color, {\n                [mode]: true,\n                'content-sizing': hostContext('ion-popover', this.el),\n                overscroll: forceOverscroll,\n                [`content-${rtl}`]: true,\n            }), style: {\n                '--offset-top': `${this.cTop}px`,\n                '--offset-bottom': `${this.cBottom}px`,\n            } }, h(\"div\", { key: 'e89aa6ea09625846db52d63bdbf06c3c279a5ba4', ref: (el) => (this.backgroundContentEl = el), id: \"background-content\", part: \"background\" }), h(\"div\", { key: '37925cf9d898ede58d5ac7b5a650c648033602a3', class: {\n                'inner-scroll': true,\n                'scroll-x': scrollX,\n                'scroll-y': scrollY,\n                overscroll: (scrollX || scrollY) && forceOverscroll,\n            }, ref: (scrollEl) => (this.scrollEl = scrollEl), onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : undefined, part: \"scroll\" }, h(\"slot\", { key: 'a40f964cacf0c2e2bdcf962791aaadb386d44323' })), transitionShadow ? (h(\"div\", { class: \"transition-effect\" }, h(\"div\", { class: \"transition-cover\" }), h(\"div\", { class: \"transition-shadow\" }))) : null, h(\"slot\", { key: 'd21886cff0bc417e1f5e3a436dddc079e967579b', name: \"fixed\" })));\n    }\n    static get is() { return \"ion-content\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"$\": [\"content.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"$\": [\"content.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"fullscreen\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the content will scroll behind the headers\\nand footers. This effect can easily be seen by setting the toolbar\\nto transparent.\"\n                },\n                \"attribute\": \"fullscreen\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"forceOverscroll\": {\n                \"type\": \"boolean\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean | undefined\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true` and the content does not cause an overflow scroll, the scroll interaction will cause a bounce.\\nIf the content exceeds the bounds of ionContent, nothing will change.\\nNote, this does not disable the system bounce on iOS. That is an OS level setting.\"\n                },\n                \"attribute\": \"force-overscroll\",\n                \"reflect\": false\n            },\n            \"scrollX\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If you want to enable the content scrolling in the X axis, set this property to `true`.\"\n                },\n                \"attribute\": \"scroll-x\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"scrollY\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If you want to disable the content scrolling in the Y axis, set this property to `false`.\"\n                },\n                \"attribute\": \"scroll-y\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"scrollEvents\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Because of performance reasons, ionScroll events are disabled by default, in order to enable them\\nand start listening from (ionScroll), set this property to `true`.\"\n                },\n                \"attribute\": \"scroll-events\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            }\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionScrollStart\",\n                \"name\": \"ionScrollStart\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the scroll has started. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n                },\n                \"complexType\": {\n                    \"original\": \"ScrollBaseDetail\",\n                    \"resolved\": \"ScrollBaseDetail\",\n                    \"references\": {\n                        \"ScrollBaseDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./content-interface\",\n                            \"id\": \"src/components/content/content-interface.ts::ScrollBaseDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionScroll\",\n                \"name\": \"ionScroll\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted while scrolling. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n                },\n                \"complexType\": {\n                    \"original\": \"ScrollDetail\",\n                    \"resolved\": \"ScrollDetail\",\n                    \"references\": {\n                        \"ScrollDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./content-interface\",\n                            \"id\": \"src/components/content/content-interface.ts::ScrollDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionScrollEnd\",\n                \"name\": \"ionScrollEnd\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the scroll has ended. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n                },\n                \"complexType\": {\n                    \"original\": \"ScrollBaseDetail\",\n                    \"resolved\": \"ScrollBaseDetail\",\n                    \"references\": {\n                        \"ScrollBaseDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./content-interface\",\n                            \"id\": \"src/components/content/content-interface.ts::ScrollBaseDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get methods() {\n        return {\n            \"getScrollElement\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<HTMLElement>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"HTMLElement\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::HTMLElement\"\n                        }\n                    },\n                    \"return\": \"Promise<HTMLElement>\"\n                },\n                \"docs\": {\n                    \"text\": \"Get the element where the actual scrolling takes place.\\nThis element can be used to subscribe to `scroll` events or manually modify\\n`scrollTop`. However, it's recommended to use the API provided by `ion-content`:\\n\\ni.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\\nand `scrollToPoint()` to scroll the content into a certain point.\",\n                    \"tags\": []\n                }\n            },\n            \"getBackgroundElement\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<HTMLElement>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        },\n                        \"HTMLElement\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::HTMLElement\"\n                        }\n                    },\n                    \"return\": \"Promise<HTMLElement>\"\n                },\n                \"docs\": {\n                    \"text\": \"Returns the background content element.\",\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }]\n                }\n            },\n            \"scrollToTop\": {\n                \"complexType\": {\n                    \"signature\": \"(duration?: number) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"duration\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount of time to take scrolling to the top. Defaults to `0`.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Scroll to the top of the component.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"duration The amount of time to take scrolling to the top. Defaults to `0`.\"\n                        }]\n                }\n            },\n            \"scrollToBottom\": {\n                \"complexType\": {\n                    \"signature\": \"(duration?: number) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"duration\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Scroll to the bottom of the component.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"duration The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n                        }]\n                }\n            },\n            \"scrollByPoint\": {\n                \"complexType\": {\n                    \"signature\": \"(x: number, y: number, duration: number) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"x\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount to scroll by on the horizontal axis.\"\n                        }, {\n                            \"name\": \"y\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount to scroll by on the vertical axis.\"\n                        }, {\n                            \"name\": \"duration\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount of time to take scrolling by that amount.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Scroll by a specified X/Y distance in the component.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"x The amount to scroll by on the horizontal axis.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"y The amount to scroll by on the vertical axis.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"duration The amount of time to take scrolling by that amount.\"\n                        }]\n                }\n            },\n            \"scrollToPoint\": {\n                \"complexType\": {\n                    \"signature\": \"(x: number | undefined | null, y: number | undefined | null, duration?: number) => Promise<void>\",\n                    \"parameters\": [{\n                            \"name\": \"x\",\n                            \"type\": \"number | null | undefined\",\n                            \"docs\": \"The point to scroll to on the horizontal axis.\"\n                        }, {\n                            \"name\": \"y\",\n                            \"type\": \"number | null | undefined\",\n                            \"docs\": \"The point to scroll to on the vertical axis.\"\n                        }, {\n                            \"name\": \"duration\",\n                            \"type\": \"number\",\n                            \"docs\": \"The amount of time to take scrolling to that point. Defaults to `0`.\"\n                        }],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"Scroll to a specified X/Y location in the component.\",\n                    \"tags\": [{\n                            \"name\": \"param\",\n                            \"text\": \"x The point to scroll to on the horizontal axis.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"y The point to scroll to on the vertical axis.\"\n                        }, {\n                            \"name\": \"param\",\n                            \"text\": \"duration The amount of time to take scrolling to that point. Defaults to `0`.\"\n                        }]\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get listeners() {\n        return [{\n                \"name\": \"resize\",\n                \"method\": \"onResize\",\n                \"target\": \"window\",\n                \"capture\": false,\n                \"passive\": true\n            }];\n    }\n}\nconst getParentElement = (el) => {\n    var _a;\n    if (el.parentElement) {\n        // normal element with a parent element\n        return el.parentElement;\n    }\n    if ((_a = el.parentNode) === null || _a === void 0 ? void 0 : _a.host) {\n        // shadow dom's document fragment\n        return el.parentNode.host;\n    }\n    return null;\n};\nconst getPageElement = (el) => {\n    const tabs = el.closest('ion-tabs');\n    if (tabs) {\n        return tabs;\n    }\n    /**\n     * If we're in a popover, we need to use its wrapper so we can account for space\n     * between the popover and the edges of the screen. But if the popover contains\n     * its own page element, we should use that instead.\n     */\n    const page = el.closest('ion-app, ion-page, .ion-page, page-inner, .popover-content');\n    if (page) {\n        return page;\n    }\n    return getParentElement(el);\n};\n// ******** DOM READ ****************\nconst updateScrollDetail = (detail, el, timestamp, shouldStart) => {\n    const prevX = detail.currentX;\n    const prevY = detail.currentY;\n    const prevT = detail.currentTime;\n    const currentX = el.scrollLeft;\n    const currentY = el.scrollTop;\n    const timeDelta = timestamp - prevT;\n    if (shouldStart) {\n        // remember the start positions\n        detail.startTime = timestamp;\n        detail.startX = currentX;\n        detail.startY = currentY;\n        detail.velocityX = detail.velocityY = 0;\n    }\n    detail.currentTime = timestamp;\n    detail.currentX = detail.scrollLeft = currentX;\n    detail.currentY = detail.scrollTop = currentY;\n    detail.deltaX = currentX - detail.startX;\n    detail.deltaY = currentY - detail.startY;\n    if (timeDelta > 0 && timeDelta < 100) {\n        const velocityX = (currentX - prevX) / timeDelta;\n        const velocityY = (currentY - prevY) / timeDelta;\n        detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n        detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n    }\n};\n"],"version":3}